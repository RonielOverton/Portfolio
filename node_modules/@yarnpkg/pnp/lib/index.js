'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const require$$0 = require('zlib');
const path = require('path');
const module$1 = require('module');
const url = require('url');
const nodeUtils = require('util');
const assert = require('assert');
const fs = require('fs');
const crypto = require('crypto');
const os = require('os');

const _interopDefaultLegacy = e => e && typeof e === 'object' && 'default' in e ? e : { default: e };

const require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0);
const path__default = /*#__PURE__*/_interopDefaultLegacy(path);
const assert__default = /*#__PURE__*/_interopDefaultLegacy(assert);
const fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);

var LinkType = /* @__PURE__ */ ((LinkType2) => {
  LinkType2["HARD"] = `HARD`;
  LinkType2["SOFT"] = `SOFT`;
  return LinkType2;
})(LinkType || {});

const SAFE_TIME = 456789e3;

const PortablePath = {
  root: `/`,
  dot: `.`,
  parent: `..`
};
const Filename = {
  home: `~`,
  nodeModules: `node_modules`,
  manifest: `package.json`,
  lockfile: `yarn.lock`,
  virtual: `__virtual__`,
  pnpJs: `.pnp.js`,
  pnpCjs: `.pnp.cjs`,
  pnpData: `.pnp.data.json`,
  pnpEsmLoader: `.pnp.loader.mjs`,
  rc: `.yarnrc.yml`,
  env: `.env`
};
const npath = Object.create(path__default.default);
const ppath = Object.create(path__default.default.posix);
npath.cwd = () => process.cwd();
ppath.cwd = process.platform === `win32` ? () => toPortablePath(process.cwd()) : process.cwd;
if (process.platform === `win32`) {
  ppath.resolve = (...segments) => {
    if (segments.length > 0 && ppath.isAbsolute(segments[0])) {
      return path__default.default.posix.resolve(...segments);
    } else {
      return path__default.default.posix.resolve(ppath.cwd(), ...segments);
    }
  };
}
const contains = function(pathUtils, from, to) {
  from = pathUtils.normalize(from);
  to = pathUtils.normalize(to);
  if (from === to)
    return `.`;
  if (!from.endsWith(pathUtils.sep))
    from = from + pathUtils.sep;
  if (to.startsWith(from)) {
    return to.slice(from.length);
  } else {
    return null;
  }
};
npath.contains = (from, to) => contains(npath, from, to);
ppath.contains = (from, to) => contains(ppath, from, to);
const WINDOWS_PATH_REGEXP = /^([a-zA-Z]:.*)$/;
const UNC_WINDOWS_PATH_REGEXP = /^\/\/(\.\/)?(.*)$/;
const PORTABLE_PATH_REGEXP = /^\/([a-zA-Z]:.*)$/;
const UNC_PORTABLE_PATH_REGEXP = /^\/unc\/(\.dot\/)?(.*)$/;
function fromPortablePathWin32(p) {
  let portablePathMatch, uncPortablePathMatch;
  if (portablePathMatch = p.match(PORTABLE_PATH_REGEXP))
    p = portablePathMatch[1];
  else if (uncPortablePathMatch = p.match(UNC_PORTABLE_PATH_REGEXP))
    p = `\\\\${uncPortablePathMatch[1] ? `.\\` : ``}${uncPortablePathMatch[2]}`;
  else
    return p;
  return p.replace(/\//g, `\\`);
}
function toPortablePathWin32(p) {
  p = p.replace(/\\/g, `/`);
  let windowsPathMatch, uncWindowsPathMatch;
  if (windowsPathMatch = p.match(WINDOWS_PATH_REGEXP))
    p = `/${windowsPathMatch[1]}`;
  else if (uncWindowsPathMatch = p.match(UNC_WINDOWS_PATH_REGEXP))
    p = `/unc/${uncWindowsPathMatch[1] ? `.dot/` : ``}${uncWindowsPathMatch[2]}`;
  return p;
}
const toPortablePath = process.platform === `win32` ? toPortablePathWin32 : (p) => p;
const fromPortablePath = process.platform === `win32` ? fromPortablePathWin32 : (p) => p;
npath.fromPortablePath = fromPortablePath;
npath.toPortablePath = toPortablePath;
function convertPath(targetPathUtils, sourcePath) {
  return targetPathUtils === npath ? fromPortablePath(sourcePath) : toPortablePath(sourcePath);
}

const defaultTime = new Date(SAFE_TIME * 1e3);
const defaultTimeMs = defaultTime.getTime();
async function copyPromise(destinationFs, destination, sourceFs, source, opts) {
  const normalizedDestination = destinationFs.pathUtils.normalize(destination);
  const normalizedSource = sourceFs.pathUtils.normalize(source);
  const prelayout = [];
  const postlayout = [];
  const { atime, mtime } = opts.stableTime ? { atime: defaultTime, mtime: defaultTime } : await sourceFs.lstatPromise(normalizedSource);
  await destinationFs.mkdirpPromise(destinationFs.pathUtils.dirname(destination), { utimes: [atime, mtime] });
  await copyImpl(prelayout, postlayout, destinationFs, normalizedDestination, sourceFs, normalizedSource, { ...opts, didParentExist: true });
  for (const operation of prelayout)
    await operation();
  await Promise.all(postlayout.map((operation) => {
    return operation();
  }));
}
async function copyImpl(prelayout, postlayout, destinationFs, destination, sourceFs, source, opts) {
  const destinationStat = opts.didParentExist ? await maybeLStat(destinationFs, destination) : null;
  const sourceStat = await sourceFs.lstatPromise(source);
  const { atime, mtime } = opts.stableTime ? { atime: defaultTime, mtime: defaultTime } : sourceStat;
  let updated;
  switch (true) {
    case sourceStat.isDirectory():
      {
        updated = await copyFolder(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
      }
      break;
    case sourceStat.isFile():
      {
        updated = await copyFile(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
      }
      break;
    case sourceStat.isSymbolicLink():
      {
        updated = await copySymlink(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
      }
      break;
    default:
      {
        throw new Error(`Unsupported file type (${sourceStat.mode})`);
      }
  }
  if (opts.linkStrategy?.type !== `HardlinkFromIndex` || !sourceStat.isFile()) {
    if (updated || destinationStat?.mtime?.getTime() !== mtime.getTime() || destinationStat?.atime?.getTime() !== atime.getTime()) {
      postlayout.push(() => destinationFs.lutimesPromise(destination, atime, mtime));
      updated = true;
    }
    if (destinationStat === null || (destinationStat.mode & 511) !== (sourceStat.mode & 511)) {
      postlayout.push(() => destinationFs.chmodPromise(destination, sourceStat.mode & 511));
      updated = true;
    }
  }
  return updated;
}
async function maybeLStat(baseFs, p) {
  try {
    return await baseFs.lstatPromise(p);
  } catch (e) {
    return null;
  }
}
async function copyFolder(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  if (destinationStat !== null && !destinationStat.isDirectory()) {
    if (opts.overwrite) {
      prelayout.push(async () => destinationFs.removePromise(destination));
      destinationStat = null;
    } else {
      return false;
    }
  }
  let updated = false;
  if (destinationStat === null) {
    prelayout.push(async () => {
      try {
        await destinationFs.mkdirPromise(destination, { mode: sourceStat.mode });
      } catch (err) {
        if (err.code !== `EEXIST`) {
          throw err;
        }
      }
    });
    updated = true;
  }
  const entries = await sourceFs.readdirPromise(source);
  const nextOpts = opts.didParentExist && !destinationStat ? { ...opts, didParentExist: false } : opts;
  if (opts.stableSort) {
    for (const entry of entries.sort()) {
      if (await copyImpl(prelayout, postlayout, destinationFs, destinationFs.pathUtils.join(destination, entry), sourceFs, sourceFs.pathUtils.join(source, entry), nextOpts)) {
        updated = true;
      }
    }
  } else {
    const entriesUpdateStatus = await Promise.all(entries.map(async (entry) => {
      await copyImpl(prelayout, postlayout, destinationFs, destinationFs.pathUtils.join(destination, entry), sourceFs, sourceFs.pathUtils.join(source, entry), nextOpts);
    }));
    if (entriesUpdateStatus.some((status) => status)) {
      updated = true;
    }
  }
  return updated;
}
async function copyFileViaIndex(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts, linkStrategy) {
  const sourceHash = await sourceFs.checksumFilePromise(source, { algorithm: `sha1` });
  const indexPath = destinationFs.pathUtils.join(linkStrategy.indexPath, sourceHash.slice(0, 2), `${sourceHash}.dat`);
  let AtomicBehavior;
  ((AtomicBehavior2) => {
    AtomicBehavior2[AtomicBehavior2["Lock"] = 0] = "Lock";
    AtomicBehavior2[AtomicBehavior2["Rename"] = 1] = "Rename";
  })(AtomicBehavior || (AtomicBehavior = {}));
  let atomicBehavior = 1 /* Rename */;
  let indexStat = await maybeLStat(destinationFs, indexPath);
  if (destinationStat) {
    const isDestinationHardlinkedFromIndex = indexStat && destinationStat.dev === indexStat.dev && destinationStat.ino === indexStat.ino;
    const isIndexModified = indexStat?.mtimeMs !== defaultTimeMs;
    if (isDestinationHardlinkedFromIndex) {
      if (isIndexModified && linkStrategy.autoRepair) {
        atomicBehavior = 0 /* Lock */;
        indexStat = null;
      }
    }
    if (!isDestinationHardlinkedFromIndex) {
      if (opts.overwrite) {
        prelayout.push(async () => destinationFs.removePromise(destination));
        destinationStat = null;
      } else {
        return false;
      }
    }
  }
  const tempPath = !indexStat && atomicBehavior === 1 /* Rename */ ? `${indexPath}.${Math.floor(Math.random() * 4294967296).toString(16).padStart(8, `0`)}` : null;
  let tempPathCleaned = false;
  prelayout.push(async () => {
    if (!indexStat) {
      if (atomicBehavior === 0 /* Lock */) {
        await destinationFs.lockPromise(indexPath, async () => {
          const content = await sourceFs.readFilePromise(source);
          await destinationFs.writeFilePromise(indexPath, content);
        });
      }
      if (atomicBehavior === 1 /* Rename */ && tempPath) {
        const content = await sourceFs.readFilePromise(source);
        await destinationFs.writeFilePromise(tempPath, content);
        try {
          await destinationFs.linkPromise(tempPath, indexPath);
        } catch (err) {
          if (err.code === `EEXIST`) {
            tempPathCleaned = true;
            await destinationFs.unlinkPromise(tempPath);
          } else {
            throw err;
          }
        }
      }
    }
    if (!destinationStat) {
      await destinationFs.linkPromise(indexPath, destination);
    }
  });
  postlayout.push(async () => {
    if (!indexStat)
      await destinationFs.lutimesPromise(indexPath, defaultTime, defaultTime);
    if (tempPath && !tempPathCleaned) {
      await destinationFs.unlinkPromise(tempPath);
    }
  });
  return false;
}
async function copyFileDirect(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  if (destinationStat !== null) {
    if (opts.overwrite) {
      prelayout.push(async () => destinationFs.removePromise(destination));
      destinationStat = null;
    } else {
      return false;
    }
  }
  prelayout.push(async () => {
    const content = await sourceFs.readFilePromise(source);
    await destinationFs.writeFilePromise(destination, content);
  });
  return true;
}
async function copyFile(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  if (opts.linkStrategy?.type === `HardlinkFromIndex`) {
    return copyFileViaIndex(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts, opts.linkStrategy);
  } else {
    return copyFileDirect(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
  }
}
async function copySymlink(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  if (destinationStat !== null) {
    if (opts.overwrite) {
      prelayout.push(async () => destinationFs.removePromise(destination));
      destinationStat = null;
    } else {
      return false;
    }
  }
  prelayout.push(async () => {
    await destinationFs.symlinkPromise(convertPath(destinationFs.pathUtils, await sourceFs.readlinkPromise(source)), destination);
  });
  return true;
}

class FakeFS {
  constructor(pathUtils) {
    this.pathUtils = pathUtils;
  }
  async *genTraversePromise(init, { stableSort = false } = {}) {
    const stack = [init];
    while (stack.length > 0) {
      const p = stack.shift();
      const entry = await this.lstatPromise(p);
      if (entry.isDirectory()) {
        const entries = await this.readdirPromise(p);
        if (stableSort) {
          for (const entry2 of entries.sort()) {
            stack.push(this.pathUtils.join(p, entry2));
          }
        } else {
          throw new Error(`Not supported`);
        }
      } else {
        yield p;
      }
    }
  }
  async checksumFilePromise(path, { algorithm = `sha512` } = {}) {
    const fd = await this.openPromise(path, `r`);
    try {
      const CHUNK_SIZE = 65536;
      const chunk = Buffer.allocUnsafeSlow(CHUNK_SIZE);
      const hash = crypto.createHash(algorithm);
      let bytesRead = 0;
      while ((bytesRead = await this.readPromise(fd, chunk, 0, CHUNK_SIZE)) !== 0)
        hash.update(bytesRead === CHUNK_SIZE ? chunk : chunk.slice(0, bytesRead));
      return hash.digest(`hex`);
    } finally {
      await this.closePromise(fd);
    }
  }
  async removePromise(p, { recursive = true, maxRetries = 5 } = {}) {
    let stat;
    try {
      stat = await this.lstatPromise(p);
    } catch (error) {
      if (error.code === `ENOENT`) {
        return;
      } else {
        throw error;
      }
    }
    if (stat.isDirectory()) {
      if (recursive) {
        const entries = await this.readdirPromise(p);
        await Promise.all(entries.map((entry) => {
          return this.removePromise(this.pathUtils.resolve(p, entry));
        }));
      }
      for (let t = 0; t <= maxRetries; t++) {
        try {
          await this.rmdirPromise(p);
          break;
        } catch (error) {
          if (error.code !== `EBUSY` && error.code !== `ENOTEMPTY`) {
            throw error;
          } else if (t < maxRetries) {
            await new Promise((resolve) => setTimeout(resolve, t * 100));
          }
        }
      }
    } else {
      await this.unlinkPromise(p);
    }
  }
  removeSync(p, { recursive = true } = {}) {
    let stat;
    try {
      stat = this.lstatSync(p);
    } catch (error) {
      if (error.code === `ENOENT`) {
        return;
      } else {
        throw error;
      }
    }
    if (stat.isDirectory()) {
      if (recursive)
        for (const entry of this.readdirSync(p))
          this.removeSync(this.pathUtils.resolve(p, entry));
      this.rmdirSync(p);
    } else {
      this.unlinkSync(p);
    }
  }
  async mkdirpPromise(p, { chmod, utimes } = {}) {
    p = this.resolve(p);
    if (p === this.pathUtils.dirname(p))
      return void 0;
    const parts = p.split(this.pathUtils.sep);
    let createdDirectory;
    for (let u = 2; u <= parts.length; ++u) {
      const subPath = parts.slice(0, u).join(this.pathUtils.sep);
      if (!this.existsSync(subPath)) {
        try {
          await this.mkdirPromise(subPath);
        } catch (error) {
          if (error.code === `EEXIST`) {
            continue;
          } else {
            throw error;
          }
        }
        createdDirectory ??= subPath;
        if (chmod != null)
          await this.chmodPromise(subPath, chmod);
        if (utimes != null) {
          await this.utimesPromise(subPath, utimes[0], utimes[1]);
        } else {
          const parentStat = await this.statPromise(this.pathUtils.dirname(subPath));
          await this.utimesPromise(subPath, parentStat.atime, parentStat.mtime);
        }
      }
    }
    return createdDirectory;
  }
  mkdirpSync(p, { chmod, utimes } = {}) {
    p = this.resolve(p);
    if (p === this.pathUtils.dirname(p))
      return void 0;
    const parts = p.split(this.pathUtils.sep);
    let createdDirectory;
    for (let u = 2; u <= parts.length; ++u) {
      const subPath = parts.slice(0, u).join(this.pathUtils.sep);
      if (!this.existsSync(subPath)) {
        try {
          this.mkdirSync(subPath);
        } catch (error) {
          if (error.code === `EEXIST`) {
            continue;
          } else {
            throw error;
          }
        }
        createdDirectory ??= subPath;
        if (chmod != null)
          this.chmodSync(subPath, chmod);
        if (utimes != null) {
          this.utimesSync(subPath, utimes[0], utimes[1]);
        } else {
          const parentStat = this.statSync(this.pathUtils.dirname(subPath));
          this.utimesSync(subPath, parentStat.atime, parentStat.mtime);
        }
      }
    }
    return createdDirectory;
  }
  async copyPromise(destination, source, { baseFs = this, overwrite = true, stableSort = false, stableTime = false, linkStrategy = null } = {}) {
    return await copyPromise(this, destination, baseFs, source, { overwrite, stableSort, stableTime, linkStrategy });
  }
  copySync(destination, source, { baseFs = this, overwrite = true } = {}) {
    const stat = baseFs.lstatSync(source);
    const exists = this.existsSync(destination);
    if (stat.isDirectory()) {
      this.mkdirpSync(destination);
      const directoryListing = baseFs.readdirSync(source);
      for (const entry of directoryListing) {
        this.copySync(this.pathUtils.join(destination, entry), baseFs.pathUtils.join(source, entry), { baseFs, overwrite });
      }
    } else if (stat.isFile()) {
      if (!exists || overwrite) {
        if (exists)
          this.removeSync(destination);
        const content = baseFs.readFileSync(source);
        this.writeFileSync(destination, content);
      }
    } else if (stat.isSymbolicLink()) {
      if (!exists || overwrite) {
        if (exists)
          this.removeSync(destination);
        const target = baseFs.readlinkSync(source);
        this.symlinkSync(convertPath(this.pathUtils, target), destination);
      }
    } else {
      throw new Error(`Unsupported file type (file: ${source}, mode: 0o${stat.mode.toString(8).padStart(6, `0`)})`);
    }
    const mode = stat.mode & 511;
    this.chmodSync(destination, mode);
  }
  async changeFilePromise(p, content, opts = {}) {
    if (Buffer.isBuffer(content)) {
      return this.changeFileBufferPromise(p, content, opts);
    } else {
      return this.changeFileTextPromise(p, content, opts);
    }
  }
  async changeFileBufferPromise(p, content, { mode } = {}) {
    let current = Buffer.alloc(0);
    try {
      current = await this.readFilePromise(p);
    } catch (error) {
    }
    if (Buffer.compare(current, content) === 0)
      return;
    await this.writeFilePromise(p, content, { mode });
  }
  async changeFileTextPromise(p, content, { automaticNewlines, mode } = {}) {
    let current = ``;
    try {
      current = await this.readFilePromise(p, `utf8`);
    } catch (error) {
    }
    const normalizedContent = automaticNewlines ? normalizeLineEndings(current, content) : content;
    if (current === normalizedContent)
      return;
    await this.writeFilePromise(p, normalizedContent, { mode });
  }
  changeFileSync(p, content, opts = {}) {
    if (Buffer.isBuffer(content)) {
      return this.changeFileBufferSync(p, content, opts);
    } else {
      return this.changeFileTextSync(p, content, opts);
    }
  }
  changeFileBufferSync(p, content, { mode } = {}) {
    let current = Buffer.alloc(0);
    try {
      current = this.readFileSync(p);
    } catch (error) {
    }
    if (Buffer.compare(current, content) === 0)
      return;
    this.writeFileSync(p, content, { mode });
  }
  changeFileTextSync(p, content, { automaticNewlines = false, mode } = {}) {
    let current = ``;
    try {
      current = this.readFileSync(p, `utf8`);
    } catch (error) {
    }
    const normalizedContent = automaticNewlines ? normalizeLineEndings(current, content) : content;
    if (current === normalizedContent)
      return;
    this.writeFileSync(p, normalizedContent, { mode });
  }
  async movePromise(fromP, toP) {
    try {
      await this.renamePromise(fromP, toP);
    } catch (error) {
      if (error.code === `EXDEV`) {
        await this.copyPromise(toP, fromP);
        await this.removePromise(fromP);
      } else {
        throw error;
      }
    }
  }
  moveSync(fromP, toP) {
    try {
      this.renameSync(fromP, toP);
    } catch (error) {
      if (error.code === `EXDEV`) {
        this.copySync(toP, fromP);
        this.removeSync(fromP);
      } else {
        throw error;
      }
    }
  }
  async lockPromise(affectedPath, callback) {
    const lockPath = `${affectedPath}.flock`;
    const interval = 1e3 / 60;
    const startTime = Date.now();
    let fd = null;
    const isAlive = async () => {
      let pid;
      try {
        [pid] = await this.readJsonPromise(lockPath);
      } catch (error) {
        return Date.now() - startTime < 500;
      }
      try {
        process.kill(pid, 0);
        return true;
      } catch (error) {
        return false;
      }
    };
    while (fd === null) {
      try {
        fd = await this.openPromise(lockPath, `wx`);
      } catch (error) {
        if (error.code === `EEXIST`) {
          if (!await isAlive()) {
            try {
              await this.unlinkPromise(lockPath);
              continue;
            } catch (error2) {
            }
          }
          if (Date.now() - startTime < 60 * 1e3) {
            await new Promise((resolve) => setTimeout(resolve, interval));
          } else {
            throw new Error(`Couldn't acquire a lock in a reasonable time (via ${lockPath})`);
          }
        } else {
          throw error;
        }
      }
    }
    await this.writePromise(fd, JSON.stringify([process.pid]));
    try {
      return await callback();
    } finally {
      try {
        await this.closePromise(fd);
        await this.unlinkPromise(lockPath);
      } catch (error) {
      }
    }
  }
  async readJsonPromise(p) {
    const content = await this.readFilePromise(p, `utf8`);
    try {
      return JSON.parse(content);
    } catch (error) {
      error.message += ` (in ${p})`;
      throw error;
    }
  }
  readJsonSync(p) {
    const content = this.readFileSync(p, `utf8`);
    try {
      return JSON.parse(content);
    } catch (error) {
      error.message += ` (in ${p})`;
      throw error;
    }
  }
  async writeJsonPromise(p, data, { compact = false } = {}) {
    const space = compact ? 0 : 2;
    return await this.writeFilePromise(p, `${JSON.stringify(data, null, space)}
`);
  }
  writeJsonSync(p, data, { compact = false } = {}) {
    const space = compact ? 0 : 2;
    return this.writeFileSync(p, `${JSON.stringify(data, null, space)}
`);
  }
  async preserveTimePromise(p, cb) {
    const stat = await this.lstatPromise(p);
    const result = await cb();
    if (typeof result !== `undefined`)
      p = result;
    await this.lutimesPromise(p, stat.atime, stat.mtime);
  }
  async preserveTimeSync(p, cb) {
    const stat = this.lstatSync(p);
    const result = cb();
    if (typeof result !== `undefined`)
      p = result;
    this.lutimesSync(p, stat.atime, stat.mtime);
  }
}
class BasePortableFakeFS extends FakeFS {
  constructor() {
    super(ppath);
  }
}
function getEndOfLine(content) {
  const matches = content.match(/\r?\n/g);
  if (matches === null)
    return os.EOL;
  const crlf = matches.filter((nl) => nl === `\r
`).length;
  const lf = matches.length - crlf;
  return crlf > lf ? `\r
` : `
`;
}
function normalizeLineEndings(originalContent, newContent) {
  return newContent.replace(/\r?\n/g, getEndOfLine(originalContent));
}

class ProxiedFS extends FakeFS {
  getExtractHint(hints) {
    return this.baseFs.getExtractHint(hints);
  }
  resolve(path) {
    return this.mapFromBase(this.baseFs.resolve(this.mapToBase(path)));
  }
  getRealPath() {
    return this.mapFromBase(this.baseFs.getRealPath());
  }
  async openPromise(p, flags, mode) {
    return this.baseFs.openPromise(this.mapToBase(p), flags, mode);
  }
  openSync(p, flags, mode) {
    return this.baseFs.openSync(this.mapToBase(p), flags, mode);
  }
  async opendirPromise(p, opts) {
    return Object.assign(await this.baseFs.opendirPromise(this.mapToBase(p), opts), { path: p });
  }
  opendirSync(p, opts) {
    return Object.assign(this.baseFs.opendirSync(this.mapToBase(p), opts), { path: p });
  }
  async readPromise(fd, buffer, offset, length, position) {
    return await this.baseFs.readPromise(fd, buffer, offset, length, position);
  }
  readSync(fd, buffer, offset, length, position) {
    return this.baseFs.readSync(fd, buffer, offset, length, position);
  }
  async writePromise(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return await this.baseFs.writePromise(fd, buffer, offset);
    } else {
      return await this.baseFs.writePromise(fd, buffer, offset, length, position);
    }
  }
  writeSync(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return this.baseFs.writeSync(fd, buffer, offset);
    } else {
      return this.baseFs.writeSync(fd, buffer, offset, length, position);
    }
  }
  async closePromise(fd) {
    return this.baseFs.closePromise(fd);
  }
  closeSync(fd) {
    this.baseFs.closeSync(fd);
  }
  createReadStream(p, opts) {
    return this.baseFs.createReadStream(p !== null ? this.mapToBase(p) : p, opts);
  }
  createWriteStream(p, opts) {
    return this.baseFs.createWriteStream(p !== null ? this.mapToBase(p) : p, opts);
  }
  async realpathPromise(p) {
    return this.mapFromBase(await this.baseFs.realpathPromise(this.mapToBase(p)));
  }
  realpathSync(p) {
    return this.mapFromBase(this.baseFs.realpathSync(this.mapToBase(p)));
  }
  async existsPromise(p) {
    return this.baseFs.existsPromise(this.mapToBase(p));
  }
  existsSync(p) {
    return this.baseFs.existsSync(this.mapToBase(p));
  }
  accessSync(p, mode) {
    return this.baseFs.accessSync(this.mapToBase(p), mode);
  }
  async accessPromise(p, mode) {
    return this.baseFs.accessPromise(this.mapToBase(p), mode);
  }
  async statPromise(p, opts) {
    return this.baseFs.statPromise(this.mapToBase(p), opts);
  }
  statSync(p, opts) {
    return this.baseFs.statSync(this.mapToBase(p), opts);
  }
  async fstatPromise(fd, opts) {
    return this.baseFs.fstatPromise(fd, opts);
  }
  fstatSync(fd, opts) {
    return this.baseFs.fstatSync(fd, opts);
  }
  lstatPromise(p, opts) {
    return this.baseFs.lstatPromise(this.mapToBase(p), opts);
  }
  lstatSync(p, opts) {
    return this.baseFs.lstatSync(this.mapToBase(p), opts);
  }
  async fchmodPromise(fd, mask) {
    return this.baseFs.fchmodPromise(fd, mask);
  }
  fchmodSync(fd, mask) {
    return this.baseFs.fchmodSync(fd, mask);
  }
  async chmodPromise(p, mask) {
    return this.baseFs.chmodPromise(this.mapToBase(p), mask);
  }
  chmodSync(p, mask) {
    return this.baseFs.chmodSync(this.mapToBase(p), mask);
  }
  async fchownPromise(fd, uid, gid) {
    return this.baseFs.fchownPromise(fd, uid, gid);
  }
  fchownSync(fd, uid, gid) {
    return this.baseFs.fchownSync(fd, uid, gid);
  }
  async chownPromise(p, uid, gid) {
    return this.baseFs.chownPromise(this.mapToBase(p), uid, gid);
  }
  chownSync(p, uid, gid) {
    return this.baseFs.chownSync(this.mapToBase(p), uid, gid);
  }
  async renamePromise(oldP, newP) {
    return this.baseFs.renamePromise(this.mapToBase(oldP), this.mapToBase(newP));
  }
  renameSync(oldP, newP) {
    return this.baseFs.renameSync(this.mapToBase(oldP), this.mapToBase(newP));
  }
  async copyFilePromise(sourceP, destP, flags = 0) {
    return this.baseFs.copyFilePromise(this.mapToBase(sourceP), this.mapToBase(destP), flags);
  }
  copyFileSync(sourceP, destP, flags = 0) {
    return this.baseFs.copyFileSync(this.mapToBase(sourceP), this.mapToBase(destP), flags);
  }
  async appendFilePromise(p, content, opts) {
    return this.baseFs.appendFilePromise(this.fsMapToBase(p), content, opts);
  }
  appendFileSync(p, content, opts) {
    return this.baseFs.appendFileSync(this.fsMapToBase(p), content, opts);
  }
  async writeFilePromise(p, content, opts) {
    return this.baseFs.writeFilePromise(this.fsMapToBase(p), content, opts);
  }
  writeFileSync(p, content, opts) {
    return this.baseFs.writeFileSync(this.fsMapToBase(p), content, opts);
  }
  async unlinkPromise(p) {
    return this.baseFs.unlinkPromise(this.mapToBase(p));
  }
  unlinkSync(p) {
    return this.baseFs.unlinkSync(this.mapToBase(p));
  }
  async utimesPromise(p, atime, mtime) {
    return this.baseFs.utimesPromise(this.mapToBase(p), atime, mtime);
  }
  utimesSync(p, atime, mtime) {
    return this.baseFs.utimesSync(this.mapToBase(p), atime, mtime);
  }
  async lutimesPromise(p, atime, mtime) {
    return this.baseFs.lutimesPromise(this.mapToBase(p), atime, mtime);
  }
  lutimesSync(p, atime, mtime) {
    return this.baseFs.lutimesSync(this.mapToBase(p), atime, mtime);
  }
  async mkdirPromise(p, opts) {
    return this.baseFs.mkdirPromise(this.mapToBase(p), opts);
  }
  mkdirSync(p, opts) {
    return this.baseFs.mkdirSync(this.mapToBase(p), opts);
  }
  async rmdirPromise(p, opts) {
    return this.baseFs.rmdirPromise(this.mapToBase(p), opts);
  }
  rmdirSync(p, opts) {
    return this.baseFs.rmdirSync(this.mapToBase(p), opts);
  }
  async linkPromise(existingP, newP) {
    return this.baseFs.linkPromise(this.mapToBase(existingP), this.mapToBase(newP));
  }
  linkSync(existingP, newP) {
    return this.baseFs.linkSync(this.mapToBase(existingP), this.mapToBase(newP));
  }
  async symlinkPromise(target, p, type) {
    const mappedP = this.mapToBase(p);
    if (this.pathUtils.isAbsolute(target))
      return this.baseFs.symlinkPromise(this.mapToBase(target), mappedP, type);
    const mappedAbsoluteTarget = this.mapToBase(this.pathUtils.join(this.pathUtils.dirname(p), target));
    const mappedTarget = this.baseFs.pathUtils.relative(this.baseFs.pathUtils.dirname(mappedP), mappedAbsoluteTarget);
    return this.baseFs.symlinkPromise(mappedTarget, mappedP, type);
  }
  symlinkSync(target, p, type) {
    const mappedP = this.mapToBase(p);
    if (this.pathUtils.isAbsolute(target))
      return this.baseFs.symlinkSync(this.mapToBase(target), mappedP, type);
    const mappedAbsoluteTarget = this.mapToBase(this.pathUtils.join(this.pathUtils.dirname(p), target));
    const mappedTarget = this.baseFs.pathUtils.relative(this.baseFs.pathUtils.dirname(mappedP), mappedAbsoluteTarget);
    return this.baseFs.symlinkSync(mappedTarget, mappedP, type);
  }
  async readFilePromise(p, encoding) {
    return this.baseFs.readFilePromise(this.fsMapToBase(p), encoding);
  }
  readFileSync(p, encoding) {
    return this.baseFs.readFileSync(this.fsMapToBase(p), encoding);
  }
  readdirPromise(p, opts) {
    return this.baseFs.readdirPromise(this.mapToBase(p), opts);
  }
  readdirSync(p, opts) {
    return this.baseFs.readdirSync(this.mapToBase(p), opts);
  }
  async readlinkPromise(p) {
    return this.mapFromBase(await this.baseFs.readlinkPromise(this.mapToBase(p)));
  }
  readlinkSync(p) {
    return this.mapFromBase(this.baseFs.readlinkSync(this.mapToBase(p)));
  }
  async truncatePromise(p, len) {
    return this.baseFs.truncatePromise(this.mapToBase(p), len);
  }
  truncateSync(p, len) {
    return this.baseFs.truncateSync(this.mapToBase(p), len);
  }
  async ftruncatePromise(fd, len) {
    return this.baseFs.ftruncatePromise(fd, len);
  }
  ftruncateSync(fd, len) {
    return this.baseFs.ftruncateSync(fd, len);
  }
  watch(p, a, b) {
    return this.baseFs.watch(
      this.mapToBase(p),
      a,
      b
    );
  }
  watchFile(p, a, b) {
    return this.baseFs.watchFile(
      this.mapToBase(p),
      a,
      b
    );
  }
  unwatchFile(p, cb) {
    return this.baseFs.unwatchFile(this.mapToBase(p), cb);
  }
  fsMapToBase(p) {
    if (typeof p === `number`) {
      return p;
    } else {
      return this.mapToBase(p);
    }
  }
}

class NodeFS extends BasePortableFakeFS {
  constructor(realFs = fs__default.default) {
    super();
    this.realFs = realFs;
  }
  getExtractHint() {
    return false;
  }
  getRealPath() {
    return PortablePath.root;
  }
  resolve(p) {
    return ppath.resolve(p);
  }
  async openPromise(p, flags, mode) {
    return await new Promise((resolve, reject) => {
      this.realFs.open(npath.fromPortablePath(p), flags, mode, this.makeCallback(resolve, reject));
    });
  }
  openSync(p, flags, mode) {
    return this.realFs.openSync(npath.fromPortablePath(p), flags, mode);
  }
  async opendirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (typeof opts !== `undefined`) {
        this.realFs.opendir(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.opendir(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    }).then((dir) => {
      const dirWithFixedPath = dir;
      Object.defineProperty(dirWithFixedPath, `path`, {
        value: p,
        configurable: true,
        writable: true
      });
      return dirWithFixedPath;
    });
  }
  opendirSync(p, opts) {
    const dir = typeof opts !== `undefined` ? this.realFs.opendirSync(npath.fromPortablePath(p), opts) : this.realFs.opendirSync(npath.fromPortablePath(p));
    const dirWithFixedPath = dir;
    Object.defineProperty(dirWithFixedPath, `path`, {
      value: p,
      configurable: true,
      writable: true
    });
    return dirWithFixedPath;
  }
  async readPromise(fd, buffer, offset = 0, length = 0, position = -1) {
    return await new Promise((resolve, reject) => {
      this.realFs.read(fd, buffer, offset, length, position, (error, bytesRead) => {
        if (error) {
          reject(error);
        } else {
          resolve(bytesRead);
        }
      });
    });
  }
  readSync(fd, buffer, offset, length, position) {
    return this.realFs.readSync(fd, buffer, offset, length, position);
  }
  async writePromise(fd, buffer, offset, length, position) {
    return await new Promise((resolve, reject) => {
      if (typeof buffer === `string`) {
        return this.realFs.write(fd, buffer, offset, this.makeCallback(resolve, reject));
      } else {
        return this.realFs.write(fd, buffer, offset, length, position, this.makeCallback(resolve, reject));
      }
    });
  }
  writeSync(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return this.realFs.writeSync(fd, buffer, offset);
    } else {
      return this.realFs.writeSync(fd, buffer, offset, length, position);
    }
  }
  async closePromise(fd) {
    await new Promise((resolve, reject) => {
      this.realFs.close(fd, this.makeCallback(resolve, reject));
    });
  }
  closeSync(fd) {
    this.realFs.closeSync(fd);
  }
  createReadStream(p, opts) {
    const realPath = p !== null ? npath.fromPortablePath(p) : p;
    return this.realFs.createReadStream(realPath, opts);
  }
  createWriteStream(p, opts) {
    const realPath = p !== null ? npath.fromPortablePath(p) : p;
    return this.realFs.createWriteStream(realPath, opts);
  }
  async realpathPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.realpath(npath.fromPortablePath(p), {}, this.makeCallback(resolve, reject));
    }).then((path) => {
      return npath.toPortablePath(path);
    });
  }
  realpathSync(p) {
    return npath.toPortablePath(this.realFs.realpathSync(npath.fromPortablePath(p), {}));
  }
  async existsPromise(p) {
    return await new Promise((resolve) => {
      this.realFs.exists(npath.fromPortablePath(p), resolve);
    });
  }
  accessSync(p, mode) {
    return this.realFs.accessSync(npath.fromPortablePath(p), mode);
  }
  async accessPromise(p, mode) {
    return await new Promise((resolve, reject) => {
      this.realFs.access(npath.fromPortablePath(p), mode, this.makeCallback(resolve, reject));
    });
  }
  existsSync(p) {
    return this.realFs.existsSync(npath.fromPortablePath(p));
  }
  async statPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        this.realFs.stat(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.stat(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    });
  }
  statSync(p, opts) {
    if (opts) {
      return this.realFs.statSync(npath.fromPortablePath(p), opts);
    } else {
      return this.realFs.statSync(npath.fromPortablePath(p));
    }
  }
  async fstatPromise(fd, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        this.realFs.fstat(fd, opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.fstat(fd, this.makeCallback(resolve, reject));
      }
    });
  }
  fstatSync(fd, opts) {
    if (opts) {
      return this.realFs.fstatSync(fd, opts);
    } else {
      return this.realFs.fstatSync(fd);
    }
  }
  async lstatPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        this.realFs.lstat(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.lstat(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    });
  }
  lstatSync(p, opts) {
    if (opts) {
      return this.realFs.lstatSync(npath.fromPortablePath(p), opts);
    } else {
      return this.realFs.lstatSync(npath.fromPortablePath(p));
    }
  }
  async fchmodPromise(fd, mask) {
    return await new Promise((resolve, reject) => {
      this.realFs.fchmod(fd, mask, this.makeCallback(resolve, reject));
    });
  }
  fchmodSync(fd, mask) {
    return this.realFs.fchmodSync(fd, mask);
  }
  async chmodPromise(p, mask) {
    return await new Promise((resolve, reject) => {
      this.realFs.chmod(npath.fromPortablePath(p), mask, this.makeCallback(resolve, reject));
    });
  }
  chmodSync(p, mask) {
    return this.realFs.chmodSync(npath.fromPortablePath(p), mask);
  }
  async fchownPromise(fd, uid, gid) {
    return await new Promise((resolve, reject) => {
      this.realFs.fchown(fd, uid, gid, this.makeCallback(resolve, reject));
    });
  }
  fchownSync(fd, uid, gid) {
    return this.realFs.fchownSync(fd, uid, gid);
  }
  async chownPromise(p, uid, gid) {
    return await new Promise((resolve, reject) => {
      this.realFs.chown(npath.fromPortablePath(p), uid, gid, this.makeCallback(resolve, reject));
    });
  }
  chownSync(p, uid, gid) {
    return this.realFs.chownSync(npath.fromPortablePath(p), uid, gid);
  }
  async renamePromise(oldP, newP) {
    return await new Promise((resolve, reject) => {
      this.realFs.rename(npath.fromPortablePath(oldP), npath.fromPortablePath(newP), this.makeCallback(resolve, reject));
    });
  }
  renameSync(oldP, newP) {
    return this.realFs.renameSync(npath.fromPortablePath(oldP), npath.fromPortablePath(newP));
  }
  async copyFilePromise(sourceP, destP, flags = 0) {
    return await new Promise((resolve, reject) => {
      this.realFs.copyFile(npath.fromPortablePath(sourceP), npath.fromPortablePath(destP), flags, this.makeCallback(resolve, reject));
    });
  }
  copyFileSync(sourceP, destP, flags = 0) {
    return this.realFs.copyFileSync(npath.fromPortablePath(sourceP), npath.fromPortablePath(destP), flags);
  }
  async appendFilePromise(p, content, opts) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
      if (opts) {
        this.realFs.appendFile(fsNativePath, content, opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.appendFile(fsNativePath, content, this.makeCallback(resolve, reject));
      }
    });
  }
  appendFileSync(p, content, opts) {
    const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
    if (opts) {
      this.realFs.appendFileSync(fsNativePath, content, opts);
    } else {
      this.realFs.appendFileSync(fsNativePath, content);
    }
  }
  async writeFilePromise(p, content, opts) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
      if (opts) {
        this.realFs.writeFile(fsNativePath, content, opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.writeFile(fsNativePath, content, this.makeCallback(resolve, reject));
      }
    });
  }
  writeFileSync(p, content, opts) {
    const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
    if (opts) {
      this.realFs.writeFileSync(fsNativePath, content, opts);
    } else {
      this.realFs.writeFileSync(fsNativePath, content);
    }
  }
  async unlinkPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.unlink(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
    });
  }
  unlinkSync(p) {
    return this.realFs.unlinkSync(npath.fromPortablePath(p));
  }
  async utimesPromise(p, atime, mtime) {
    return await new Promise((resolve, reject) => {
      this.realFs.utimes(npath.fromPortablePath(p), atime, mtime, this.makeCallback(resolve, reject));
    });
  }
  utimesSync(p, atime, mtime) {
    this.realFs.utimesSync(npath.fromPortablePath(p), atime, mtime);
  }
  async lutimesPromise(p, atime, mtime) {
    return await new Promise((resolve, reject) => {
      this.realFs.lutimes(npath.fromPortablePath(p), atime, mtime, this.makeCallback(resolve, reject));
    });
  }
  lutimesSync(p, atime, mtime) {
    this.realFs.lutimesSync(npath.fromPortablePath(p), atime, mtime);
  }
  async mkdirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      this.realFs.mkdir(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
    });
  }
  mkdirSync(p, opts) {
    return this.realFs.mkdirSync(npath.fromPortablePath(p), opts);
  }
  async rmdirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        this.realFs.rmdir(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.rmdir(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    });
  }
  rmdirSync(p, opts) {
    return this.realFs.rmdirSync(npath.fromPortablePath(p), opts);
  }
  async linkPromise(existingP, newP) {
    return await new Promise((resolve, reject) => {
      this.realFs.link(npath.fromPortablePath(existingP), npath.fromPortablePath(newP), this.makeCallback(resolve, reject));
    });
  }
  linkSync(existingP, newP) {
    return this.realFs.linkSync(npath.fromPortablePath(existingP), npath.fromPortablePath(newP));
  }
  async symlinkPromise(target, p, type) {
    return await new Promise((resolve, reject) => {
      this.realFs.symlink(npath.fromPortablePath(target.replace(/\/+$/, ``)), npath.fromPortablePath(p), type, this.makeCallback(resolve, reject));
    });
  }
  symlinkSync(target, p, type) {
    return this.realFs.symlinkSync(npath.fromPortablePath(target.replace(/\/+$/, ``)), npath.fromPortablePath(p), type);
  }
  async readFilePromise(p, encoding) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
      this.realFs.readFile(fsNativePath, encoding, this.makeCallback(resolve, reject));
    });
  }
  readFileSync(p, encoding) {
    const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
    return this.realFs.readFileSync(fsNativePath, encoding);
  }
  async readdirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        this.realFs.readdir(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.readdir(npath.fromPortablePath(p), this.makeCallback((value) => resolve(value), reject));
      }
    });
  }
  readdirSync(p, opts) {
    if (opts) {
      return this.realFs.readdirSync(npath.fromPortablePath(p), opts);
    } else {
      return this.realFs.readdirSync(npath.fromPortablePath(p));
    }
  }
  async readlinkPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.readlink(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
    }).then((path) => {
      return npath.toPortablePath(path);
    });
  }
  readlinkSync(p) {
    return npath.toPortablePath(this.realFs.readlinkSync(npath.fromPortablePath(p)));
  }
  async truncatePromise(p, len) {
    return await new Promise((resolve, reject) => {
      this.realFs.truncate(npath.fromPortablePath(p), len, this.makeCallback(resolve, reject));
    });
  }
  truncateSync(p, len) {
    return this.realFs.truncateSync(npath.fromPortablePath(p), len);
  }
  async ftruncatePromise(fd, len) {
    return await new Promise((resolve, reject) => {
      this.realFs.ftruncate(fd, len, this.makeCallback(resolve, reject));
    });
  }
  ftruncateSync(fd, len) {
    return this.realFs.ftruncateSync(fd, len);
  }
  watch(p, a, b) {
    return this.realFs.watch(
      npath.fromPortablePath(p),
      a,
      b
    );
  }
  watchFile(p, a, b) {
    return this.realFs.watchFile(
      npath.fromPortablePath(p),
      a,
      b
    );
  }
  unwatchFile(p, cb) {
    return this.realFs.unwatchFile(npath.fromPortablePath(p), cb);
  }
  makeCallback(resolve, reject) {
    return (err, result) => {
      if (err) {
        reject(err);
      } else {
        resolve(result);
      }
    };
  }
}

const NUMBER_REGEXP = /^[0-9]+$/;
const VIRTUAL_REGEXP = /^(\/(?:[^/]+\/)*?(?:\$\$virtual|__virtual__))((?:\/((?:[^/]+-)?[a-f0-9]+)(?:\/([^/]+))?)?((?:\/.*)?))$/;
const VALID_COMPONENT = /^([^/]+-)?[a-f0-9]+$/;
class VirtualFS extends ProxiedFS {
  constructor({ baseFs = new NodeFS() } = {}) {
    super(ppath);
    this.baseFs = baseFs;
  }
  static makeVirtualPath(base, component, to) {
    if (ppath.basename(base) !== `__virtual__`)
      throw new Error(`Assertion failed: Virtual folders must be named "__virtual__"`);
    if (!ppath.basename(component).match(VALID_COMPONENT))
      throw new Error(`Assertion failed: Virtual components must be ended by an hexadecimal hash`);
    const target = ppath.relative(ppath.dirname(base), to);
    const segments = target.split(`/`);
    let depth = 0;
    while (depth < segments.length && segments[depth] === `..`)
      depth += 1;
    const finalSegments = segments.slice(depth);
    const fullVirtualPath = ppath.join(base, component, String(depth), ...finalSegments);
    return fullVirtualPath;
  }
  static resolveVirtual(p) {
    const match = p.match(VIRTUAL_REGEXP);
    if (!match || !match[3] && match[5])
      return p;
    const target = ppath.dirname(match[1]);
    if (!match[3] || !match[4])
      return target;
    const isnum = NUMBER_REGEXP.test(match[4]);
    if (!isnum)
      return p;
    const depth = Number(match[4]);
    const backstep = `../`.repeat(depth);
    const subpath = match[5] || `.`;
    return VirtualFS.resolveVirtual(ppath.join(target, backstep, subpath));
  }
  getExtractHint(hints) {
    return this.baseFs.getExtractHint(hints);
  }
  getRealPath() {
    return this.baseFs.getRealPath();
  }
  realpathSync(p) {
    const match = p.match(VIRTUAL_REGEXP);
    if (!match)
      return this.baseFs.realpathSync(p);
    if (!match[5])
      return p;
    const realpath = this.baseFs.realpathSync(this.mapToBase(p));
    return VirtualFS.makeVirtualPath(match[1], match[3], realpath);
  }
  async realpathPromise(p) {
    const match = p.match(VIRTUAL_REGEXP);
    if (!match)
      return await this.baseFs.realpathPromise(p);
    if (!match[5])
      return p;
    const realpath = await this.baseFs.realpathPromise(this.mapToBase(p));
    return VirtualFS.makeVirtualPath(match[1], match[3], realpath);
  }
  mapToBase(p) {
    if (p === ``)
      return p;
    if (this.pathUtils.isAbsolute(p))
      return VirtualFS.resolveVirtual(p);
    const resolvedRoot = VirtualFS.resolveVirtual(this.baseFs.resolve(PortablePath.dot));
    const resolvedP = VirtualFS.resolveVirtual(this.baseFs.resolve(p));
    return ppath.relative(resolvedRoot, resolvedP) || PortablePath.dot;
  }
  mapFromBase(p) {
    return p;
  }
}

const prettyJsonMachine = {
  ["DEFAULT" /* DEFAULT */]: {
    collapsed: false,
    next: {
      [`*`]: "DEFAULT" /* DEFAULT */
    }
  },
  ["TOP_LEVEL" /* TOP_LEVEL */]: {
    collapsed: false,
    next: {
      [`fallbackExclusionList`]: "FALLBACK_EXCLUSION_LIST" /* FALLBACK_EXCLUSION_LIST */,
      [`packageRegistryData`]: "PACKAGE_REGISTRY_DATA" /* PACKAGE_REGISTRY_DATA */,
      [`*`]: "DEFAULT" /* DEFAULT */
    }
  },
  ["FALLBACK_EXCLUSION_LIST" /* FALLBACK_EXCLUSION_LIST */]: {
    collapsed: false,
    next: {
      [`*`]: "FALLBACK_EXCLUSION_ENTRIES" /* FALLBACK_EXCLUSION_ENTRIES */
    }
  },
  ["FALLBACK_EXCLUSION_ENTRIES" /* FALLBACK_EXCLUSION_ENTRIES */]: {
    collapsed: true,
    next: {
      [`*`]: "FALLBACK_EXCLUSION_DATA" /* FALLBACK_EXCLUSION_DATA */
    }
  },
  ["FALLBACK_EXCLUSION_DATA" /* FALLBACK_EXCLUSION_DATA */]: {
    collapsed: true,
    next: {
      [`*`]: "DEFAULT" /* DEFAULT */
    }
  },
  ["PACKAGE_REGISTRY_DATA" /* PACKAGE_REGISTRY_DATA */]: {
    collapsed: false,
    next: {
      [`*`]: "PACKAGE_REGISTRY_ENTRIES" /* PACKAGE_REGISTRY_ENTRIES */
    }
  },
  ["PACKAGE_REGISTRY_ENTRIES" /* PACKAGE_REGISTRY_ENTRIES */]: {
    collapsed: true,
    next: {
      [`*`]: "PACKAGE_STORE_DATA" /* PACKAGE_STORE_DATA */
    }
  },
  ["PACKAGE_STORE_DATA" /* PACKAGE_STORE_DATA */]: {
    collapsed: false,
    next: {
      [`*`]: "PACKAGE_STORE_ENTRIES" /* PACKAGE_STORE_ENTRIES */
    }
  },
  ["PACKAGE_STORE_ENTRIES" /* PACKAGE_STORE_ENTRIES */]: {
    collapsed: true,
    next: {
      [`*`]: "PACKAGE_INFORMATION_DATA" /* PACKAGE_INFORMATION_DATA */
    }
  },
  ["PACKAGE_INFORMATION_DATA" /* PACKAGE_INFORMATION_DATA */]: {
    collapsed: false,
    next: {
      [`packageDependencies`]: "PACKAGE_DEPENDENCIES" /* PACKAGE_DEPENDENCIES */,
      [`*`]: "DEFAULT" /* DEFAULT */
    }
  },
  ["PACKAGE_DEPENDENCIES" /* PACKAGE_DEPENDENCIES */]: {
    collapsed: false,
    next: {
      [`*`]: "PACKAGE_DEPENDENCY" /* PACKAGE_DEPENDENCY */
    }
  },
  ["PACKAGE_DEPENDENCY" /* PACKAGE_DEPENDENCY */]: {
    collapsed: true,
    next: {
      [`*`]: "DEFAULT" /* DEFAULT */
    }
  }
};
function generateCollapsedArray(data, state, indent) {
  let result = ``;
  result += `[`;
  for (let t = 0, T = data.length; t < T; ++t) {
    result += generateNext(String(t), data[t], state, indent).replace(/^ +/g, ``);
    if (t + 1 < T) {
      result += `, `;
    }
  }
  result += `]`;
  return result;
}
function generateExpandedArray(data, state, indent) {
  const nextIndent = `${indent}  `;
  let result = ``;
  result += indent;
  result += `[
`;
  for (let t = 0, T = data.length; t < T; ++t) {
    result += nextIndent + generateNext(String(t), data[t], state, nextIndent).replace(/^ +/, ``);
    if (t + 1 < T)
      result += `,`;
    result += `
`;
  }
  result += indent;
  result += `]`;
  return result;
}
function generateCollapsedObject(data, state, indent) {
  const keys = Object.keys(data);
  let result = ``;
  result += `{`;
  for (let t = 0, T = keys.length, keysPrinted = 0; t < T; ++t) {
    const key = keys[t];
    const value = data[key];
    if (typeof value === `undefined`)
      continue;
    if (keysPrinted !== 0)
      result += `, `;
    result += JSON.stringify(key);
    result += `: `;
    result += generateNext(key, value, state, indent).replace(/^ +/g, ``);
    keysPrinted += 1;
  }
  result += `}`;
  return result;
}
function generateExpandedObject(data, state, indent) {
  const keys = Object.keys(data);
  const nextIndent = `${indent}  `;
  let result = ``;
  result += indent;
  result += `{
`;
  let keysPrinted = 0;
  for (let t = 0, T = keys.length; t < T; ++t) {
    const key = keys[t];
    const value = data[key];
    if (typeof value === `undefined`)
      continue;
    if (keysPrinted !== 0) {
      result += `,`;
      result += `
`;
    }
    result += nextIndent;
    result += JSON.stringify(key);
    result += `: `;
    result += generateNext(key, value, state, nextIndent).replace(/^ +/g, ``);
    keysPrinted += 1;
  }
  if (keysPrinted !== 0)
    result += `
`;
  result += indent;
  result += `}`;
  return result;
}
function generateNext(key, data, state, indent) {
  const { next } = prettyJsonMachine[state];
  const nextState = next[key] || next[`*`];
  return generate(data, nextState, indent);
}
function generate(data, state, indent) {
  const { collapsed } = prettyJsonMachine[state];
  if (Array.isArray(data)) {
    if (collapsed) {
      return generateCollapsedArray(data, state, indent);
    } else {
      return generateExpandedArray(data, state, indent);
    }
  }
  if (typeof data === `object` && data !== null) {
    if (collapsed) {
      return generateCollapsedObject(data, state, indent);
    } else {
      return generateExpandedObject(data, state, indent);
    }
  }
  return JSON.stringify(data);
}
function generatePrettyJson(data) {
  return generate(data, "TOP_LEVEL" /* TOP_LEVEL */, ``);
}

function sortMap(values, mappers) {
  const asArray = Array.from(values);
  if (!Array.isArray(mappers))
    mappers = [mappers];
  const stringified = [];
  for (const mapper of mappers)
    stringified.push(asArray.map((value) => mapper(value)));
  const indices = asArray.map((_, index) => index);
  indices.sort((a, b) => {
    for (const layer of stringified) {
      const comparison = layer[a] < layer[b] ? -1 : layer[a] > layer[b] ? 1 : 0;
      if (comparison !== 0) {
        return comparison;
      }
    }
    return 0;
  });
  return indices.map((index) => {
    return asArray[index];
  });
}
function generateFallbackExclusionList(settings) {
  const fallbackExclusionList = /* @__PURE__ */ new Map();
  const sortedData = sortMap(settings.fallbackExclusionList || [], [
    ({ name, reference }) => name,
    ({ name, reference }) => reference
  ]);
  for (const { name, reference } of sortedData) {
    let references = fallbackExclusionList.get(name);
    if (typeof references === `undefined`)
      fallbackExclusionList.set(name, references = /* @__PURE__ */ new Set());
    references.add(reference);
  }
  return Array.from(fallbackExclusionList).map(([name, references]) => {
    return [name, Array.from(references)];
  });
}
function generateFallbackPoolData(settings) {
  return sortMap(settings.fallbackPool || [], ([name]) => name);
}
function generatePackageRegistryData(settings) {
  const packageRegistryData = [];
  for (const [packageName, packageStore] of sortMap(settings.packageRegistry, ([packageName2]) => packageName2 === null ? `0` : `1${packageName2}`)) {
    const packageStoreData = [];
    packageRegistryData.push([packageName, packageStoreData]);
    for (const [packageReference, { packageLocation, packageDependencies, packagePeers, linkType, discardFromLookup }] of sortMap(packageStore, ([packageReference2]) => packageReference2 === null ? `0` : `1${packageReference2}`)) {
      const normalizedDependencies = [];
      if (packageName !== null && packageReference !== null && !packageDependencies.has(packageName))
        normalizedDependencies.push([packageName, packageReference]);
      for (const [dependencyName, dependencyReference] of sortMap(packageDependencies.entries(), ([dependencyName2]) => dependencyName2))
        normalizedDependencies.push([dependencyName, dependencyReference]);
      const normalizedPeers = packagePeers && packagePeers.size > 0 ? Array.from(packagePeers) : void 0;
      const normalizedDiscardFromLookup = discardFromLookup ? discardFromLookup : void 0;
      packageStoreData.push([packageReference, {
        packageLocation,
        packageDependencies: normalizedDependencies,
        packagePeers: normalizedPeers,
        linkType,
        discardFromLookup: normalizedDiscardFromLookup
      }]);
    }
  }
  return packageRegistryData;
}
function generateSerializedState(settings) {
  return {
    __info: [
      `This file is automatically generated. Do not touch it, or risk`,
      `your modifications being lost.`
    ],
    dependencyTreeRoots: settings.dependencyTreeRoots,
    enableTopLevelFallback: settings.enableTopLevelFallback || false,
    ignorePatternData: settings.ignorePattern || null,
    fallbackExclusionList: generateFallbackExclusionList(settings),
    fallbackPool: generateFallbackPoolData(settings),
    packageRegistryData: generatePackageRegistryData(settings)
  };
}

let hook$1;
var hook_1 = () => {
  if (typeof hook$1 === `undefined`)
    hook$1 = require$$0__default.default.brotliDecompressSync(Buffer.from("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", "base64")).toString();
  return hook$1;
};

function generateLoader(shebang, loader) {
  return [
    shebang ? `${shebang}
` : ``,
    `/* eslint-disable */
`,
    `"use strict";
`,
    `
`,
    loader,
    `
`,
    hook_1()
  ].join(``);
}
function generateJsonString(data) {
  return JSON.stringify(data, null, 2);
}
function generateStringLiteral(value) {
  return `'${value.replace(/\\/g, `\\\\`).replace(/'/g, `\\'`).replace(/\n/g, `\\
`)}'`;
}
function generateInlinedSetup(data) {
  return [
    `const RAW_RUNTIME_STATE =
`,
    `${generateStringLiteral(generatePrettyJson(data))};

`,
    `function $$SETUP_STATE(hydrateRuntimeState, basePath) {
`,
    `  return hydrateRuntimeState(JSON.parse(RAW_RUNTIME_STATE), {basePath: basePath || __dirname});
`,
    `}
`
  ].join(``);
}
function generateSplitSetup() {
  return [
    `function $$SETUP_STATE(hydrateRuntimeState, basePath) {
`,
    `  const fs = require('fs');
`,
    `  const path = require('path');
`,
    `  const pnpDataFilepath = path.resolve(__dirname, ${JSON.stringify(Filename.pnpData)});
`,
    `  return hydrateRuntimeState(JSON.parse(fs.readFileSync(pnpDataFilepath, 'utf8')), {basePath: basePath || __dirname});
`,
    `}
`
  ].join(``);
}
function generateInlinedScript(settings) {
  const data = generateSerializedState(settings);
  const setup = generateInlinedSetup(data);
  const loaderFile = generateLoader(settings.shebang, setup);
  return loaderFile;
}
function generateSplitScript(settings) {
  const data = generateSerializedState(settings);
  const setup = generateSplitSetup();
  const loaderFile = generateLoader(settings.shebang, setup);
  return { dataFile: generateJsonString(data), loaderFile };
}

function hydrateRuntimeState(data, { basePath }) {
  const portablePath = npath.toPortablePath(basePath);
  const absolutePortablePath = ppath.resolve(portablePath);
  const ignorePattern = data.ignorePatternData !== null ? new RegExp(data.ignorePatternData) : null;
  const packageLocatorsByLocations = /* @__PURE__ */ new Map();
  const packageRegistry = new Map(data.packageRegistryData.map(([packageName, packageStoreData]) => {
    return [packageName, new Map(packageStoreData.map(([packageReference, packageInformationData]) => {
      if (packageName === null !== (packageReference === null))
        throw new Error(`Assertion failed: The name and reference should be null, or neither should`);
      const discardFromLookup = packageInformationData.discardFromLookup ?? false;
      const packageLocator = { name: packageName, reference: packageReference };
      const entry = packageLocatorsByLocations.get(packageInformationData.packageLocation);
      if (!entry) {
        packageLocatorsByLocations.set(packageInformationData.packageLocation, { locator: packageLocator, discardFromLookup });
      } else {
        entry.discardFromLookup = entry.discardFromLookup && discardFromLookup;
        if (!discardFromLookup) {
          entry.locator = packageLocator;
        }
      }
      let resolvedPackageLocation = null;
      return [packageReference, {
        packageDependencies: new Map(packageInformationData.packageDependencies),
        packagePeers: new Set(packageInformationData.packagePeers),
        linkType: packageInformationData.linkType,
        discardFromLookup,
        get packageLocation() {
          return resolvedPackageLocation || (resolvedPackageLocation = ppath.join(absolutePortablePath, packageInformationData.packageLocation));
        }
      }];
    }))];
  }));
  const fallbackExclusionList = new Map(data.fallbackExclusionList.map(([packageName, packageReferences]) => {
    return [packageName, new Set(packageReferences)];
  }));
  const fallbackPool = new Map(data.fallbackPool);
  const dependencyTreeRoots = data.dependencyTreeRoots;
  const enableTopLevelFallback = data.enableTopLevelFallback;
  return {
    basePath: portablePath,
    dependencyTreeRoots,
    enableTopLevelFallback,
    fallbackExclusionList,
    fallbackPool,
    ignorePattern,
    packageLocatorsByLocations,
    packageRegistry
  };
}

const ArrayIsArray = Array.isArray;
const JSONStringify = JSON.stringify;
const ObjectGetOwnPropertyNames = Object.getOwnPropertyNames;
const ObjectPrototypeHasOwnProperty = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
const RegExpPrototypeExec = (obj, string) => RegExp.prototype.exec.call(obj, string);
const RegExpPrototypeSymbolReplace = (obj, ...rest) => RegExp.prototype[Symbol.replace].apply(obj, rest);
const StringPrototypeEndsWith = (str, ...rest) => String.prototype.endsWith.apply(str, rest);
const StringPrototypeIncludes = (str, ...rest) => String.prototype.includes.apply(str, rest);
const StringPrototypeLastIndexOf = (str, ...rest) => String.prototype.lastIndexOf.apply(str, rest);
const StringPrototypeIndexOf = (str, ...rest) => String.prototype.indexOf.apply(str, rest);
const StringPrototypeReplace = (str, ...rest) => String.prototype.replace.apply(str, rest);
const StringPrototypeSlice = (str, ...rest) => String.prototype.slice.apply(str, rest);
const StringPrototypeStartsWith = (str, ...rest) => String.prototype.startsWith.apply(str, rest);
const SafeMap = Map;
const JSONParse = JSON.parse;

function createErrorType(code, messageCreator, errorType) {
  return class extends errorType {
    constructor(...args) {
      super(messageCreator(...args));
      this.code = code;
      this.name = `${errorType.name} [${code}]`;
    }
  };
}
const ERR_PACKAGE_IMPORT_NOT_DEFINED = createErrorType(
  `ERR_PACKAGE_IMPORT_NOT_DEFINED`,
  (specifier, packagePath, base) => {
    return `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ``} imported from ${base}`;
  },
  TypeError
);
const ERR_INVALID_MODULE_SPECIFIER = createErrorType(
  `ERR_INVALID_MODULE_SPECIFIER`,
  (request, reason, base = void 0) => {
    return `Invalid module "${request}" ${reason}${base ? ` imported from ${base}` : ``}`;
  },
  TypeError
);
const ERR_INVALID_PACKAGE_TARGET = createErrorType(
  `ERR_INVALID_PACKAGE_TARGET`,
  (pkgPath, key, target, isImport = false, base = void 0) => {
    const relError = typeof target === `string` && !isImport && target.length && !StringPrototypeStartsWith(target, `./`);
    if (key === `.`) {
      assert__default.default(isImport === false);
      return `Invalid "exports" main target ${JSONStringify(target)} defined in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ``}${relError ? `; targets must start with "./"` : ``}`;
    }
    return `Invalid "${isImport ? `imports` : `exports`}" target ${JSONStringify(
      target
    )} defined for '${key}' in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ``}${relError ? `; targets must start with "./"` : ``}`;
  },
  Error
);
const ERR_INVALID_PACKAGE_CONFIG = createErrorType(
  `ERR_INVALID_PACKAGE_CONFIG`,
  (path, base, message) => {
    return `Invalid package config ${path}${base ? ` while importing ${base}` : ``}${message ? `. ${message}` : ``}`;
  },
  Error
);
const ERR_PACKAGE_PATH_NOT_EXPORTED = createErrorType(
  "ERR_PACKAGE_PATH_NOT_EXPORTED",
  (pkgPath, subpath, base = void 0) => {
    if (subpath === ".")
      return `No "exports" main defined in ${pkgPath}package.json${base ? ` imported from ${base}` : ""}`;
    return `Package subpath '${subpath}' is not defined by "exports" in ${pkgPath}package.json${base ? ` imported from ${base}` : ""}`;
  },
  Error
);

function filterOwnProperties(source, keys) {
  const filtered = /* @__PURE__ */ Object.create(null);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    if (ObjectPrototypeHasOwnProperty(source, key)) {
      filtered[key] = source[key];
    }
  }
  return filtered;
}

const packageJSONCache = new SafeMap();
function getPackageConfig(path, specifier, base, readFileSyncFn) {
  const existing = packageJSONCache.get(path);
  if (existing !== void 0) {
    return existing;
  }
  const source = readFileSyncFn(path);
  if (source === void 0) {
    const packageConfig2 = {
      pjsonPath: path,
      exists: false,
      main: void 0,
      name: void 0,
      type: "none",
      exports: void 0,
      imports: void 0
    };
    packageJSONCache.set(path, packageConfig2);
    return packageConfig2;
  }
  let packageJSON;
  try {
    packageJSON = JSONParse(source);
  } catch (error) {
    throw new ERR_INVALID_PACKAGE_CONFIG(
      path,
      (base ? `"${specifier}" from ` : "") + url.fileURLToPath(base || specifier),
      error.message
    );
  }
  let { imports, main, name, type } = filterOwnProperties(packageJSON, [
    "imports",
    "main",
    "name",
    "type"
  ]);
  const exports = ObjectPrototypeHasOwnProperty(packageJSON, "exports") ? packageJSON.exports : void 0;
  if (typeof imports !== "object" || imports === null) {
    imports = void 0;
  }
  if (typeof main !== "string") {
    main = void 0;
  }
  if (typeof name !== "string") {
    name = void 0;
  }
  if (type !== "module" && type !== "commonjs") {
    type = "none";
  }
  const packageConfig = {
    pjsonPath: path,
    exists: true,
    main,
    name,
    type,
    exports,
    imports
  };
  packageJSONCache.set(path, packageConfig);
  return packageConfig;
}
function getPackageScopeConfig(resolved, readFileSyncFn) {
  let packageJSONUrl = new URL("./package.json", resolved);
  while (true) {
    const packageJSONPath2 = packageJSONUrl.pathname;
    if (StringPrototypeEndsWith(packageJSONPath2, "node_modules/package.json")) {
      break;
    }
    const packageConfig2 = getPackageConfig(
      url.fileURLToPath(packageJSONUrl),
      resolved,
      void 0,
      readFileSyncFn
    );
    if (packageConfig2.exists) {
      return packageConfig2;
    }
    const lastPackageJSONUrl = packageJSONUrl;
    packageJSONUrl = new URL("../package.json", packageJSONUrl);
    if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) {
      break;
    }
  }
  const packageJSONPath = url.fileURLToPath(packageJSONUrl);
  const packageConfig = {
    pjsonPath: packageJSONPath,
    exists: false,
    main: void 0,
    name: void 0,
    type: "none",
    exports: void 0,
    imports: void 0
  };
  packageJSONCache.set(packageJSONPath, packageConfig);
  return packageConfig;
}

/**
  @license
  Copyright Node.js contributors. All rights reserved.

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to
  deal in the Software without restriction, including without limitation the
  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
  sell copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
  IN THE SOFTWARE.
*/
function throwImportNotDefined(specifier, packageJSONUrl, base) {
  throw new ERR_PACKAGE_IMPORT_NOT_DEFINED(
    specifier,
    packageJSONUrl && url.fileURLToPath(new URL(".", packageJSONUrl)),
    url.fileURLToPath(base)
  );
}
function throwInvalidSubpath(subpath, packageJSONUrl, internal, base) {
  const reason = `request is not a valid subpath for the "${internal ? "imports" : "exports"}" resolution of ${url.fileURLToPath(packageJSONUrl)}`;
  throw new ERR_INVALID_MODULE_SPECIFIER(
    subpath,
    reason,
    base && url.fileURLToPath(base)
  );
}
function throwInvalidPackageTarget(subpath, target, packageJSONUrl, internal, base) {
  if (typeof target === "object" && target !== null) {
    target = JSONStringify(target, null, "");
  } else {
    target = `${target}`;
  }
  throw new ERR_INVALID_PACKAGE_TARGET(
    url.fileURLToPath(new URL(".", packageJSONUrl)),
    subpath,
    target,
    internal,
    base && url.fileURLToPath(base)
  );
}
const invalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i;
const patternRegEx = /\*/g;
function resolvePackageTargetString(target, subpath, match, packageJSONUrl, base, pattern, internal, conditions) {
  if (subpath !== "" && !pattern && target[target.length - 1] !== "/")
    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);
  if (!StringPrototypeStartsWith(target, "./")) {
    if (internal && !StringPrototypeStartsWith(target, "../") && !StringPrototypeStartsWith(target, "/")) {
      let isURL = false;
      try {
        new URL(target);
        isURL = true;
      } catch {
      }
      if (!isURL) {
        const exportTarget = pattern ? RegExpPrototypeSymbolReplace(patternRegEx, target, () => subpath) : target + subpath;
        return exportTarget;
      }
    }
    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);
  }
  if (RegExpPrototypeExec(
    invalidSegmentRegEx,
    StringPrototypeSlice(target, 2)
  ) !== null)
    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);
  const resolved = new URL(target, packageJSONUrl);
  const resolvedPath = resolved.pathname;
  const packagePath = new URL(".", packageJSONUrl).pathname;
  if (!StringPrototypeStartsWith(resolvedPath, packagePath))
    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);
  if (subpath === "")
    return resolved;
  if (RegExpPrototypeExec(invalidSegmentRegEx, subpath) !== null) {
    const request = pattern ? StringPrototypeReplace(match, "*", () => subpath) : match + subpath;
    throwInvalidSubpath(request, packageJSONUrl, internal, base);
  }
  if (pattern) {
    return new URL(
      RegExpPrototypeSymbolReplace(patternRegEx, resolved.href, () => subpath)
    );
  }
  return new URL(subpath, resolved);
}
function isArrayIndex(key) {
  const keyNum = +key;
  if (`${keyNum}` !== key)
    return false;
  return keyNum >= 0 && keyNum < 4294967295;
}
function resolvePackageTarget(packageJSONUrl, target, subpath, packageSubpath, base, pattern, internal, conditions) {
  if (typeof target === "string") {
    return resolvePackageTargetString(
      target,
      subpath,
      packageSubpath,
      packageJSONUrl,
      base,
      pattern,
      internal);
  } else if (ArrayIsArray(target)) {
    if (target.length === 0) {
      return null;
    }
    let lastException;
    for (let i = 0; i < target.length; i++) {
      const targetItem = target[i];
      let resolveResult;
      try {
        resolveResult = resolvePackageTarget(
          packageJSONUrl,
          targetItem,
          subpath,
          packageSubpath,
          base,
          pattern,
          internal,
          conditions
        );
      } catch (e) {
        lastException = e;
        if (e.code === "ERR_INVALID_PACKAGE_TARGET") {
          continue;
        }
        throw e;
      }
      if (resolveResult === void 0) {
        continue;
      }
      if (resolveResult === null) {
        lastException = null;
        continue;
      }
      return resolveResult;
    }
    if (lastException === void 0 || lastException === null)
      return lastException;
    throw lastException;
  } else if (typeof target === "object" && target !== null) {
    const keys = ObjectGetOwnPropertyNames(target);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (isArrayIndex(key)) {
        throw new ERR_INVALID_PACKAGE_CONFIG(
          url.fileURLToPath(packageJSONUrl),
          base,
          '"exports" cannot contain numeric property keys.'
        );
      }
    }
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (key === "default" || conditions.has(key)) {
        const conditionalTarget = target[key];
        const resolveResult = resolvePackageTarget(
          packageJSONUrl,
          conditionalTarget,
          subpath,
          packageSubpath,
          base,
          pattern,
          internal,
          conditions
        );
        if (resolveResult === void 0)
          continue;
        return resolveResult;
      }
    }
    return void 0;
  } else if (target === null) {
    return null;
  }
  throwInvalidPackageTarget(
    packageSubpath,
    target,
    packageJSONUrl,
    internal,
    base
  );
}
function patternKeyCompare(a, b) {
  const aPatternIndex = StringPrototypeIndexOf(a, "*");
  const bPatternIndex = StringPrototypeIndexOf(b, "*");
  const baseLenA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;
  const baseLenB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;
  if (baseLenA > baseLenB)
    return -1;
  if (baseLenB > baseLenA)
    return 1;
  if (aPatternIndex === -1)
    return 1;
  if (bPatternIndex === -1)
    return -1;
  if (a.length > b.length)
    return -1;
  if (b.length > a.length)
    return 1;
  return 0;
}
function isConditionalExportsMainSugar(exports, packageJSONUrl, base) {
  if (typeof exports === "string" || ArrayIsArray(exports))
    return true;
  if (typeof exports !== "object" || exports === null)
    return false;
  const keys = ObjectGetOwnPropertyNames(exports);
  let isConditionalSugar = false;
  let i = 0;
  for (let j = 0; j < keys.length; j++) {
    const key = keys[j];
    const curIsConditionalSugar = key === "" || key[0] !== ".";
    if (i++ === 0) {
      isConditionalSugar = curIsConditionalSugar;
    } else if (isConditionalSugar !== curIsConditionalSugar) {
      throw new ERR_INVALID_PACKAGE_CONFIG(
        url.fileURLToPath(packageJSONUrl),
        base,
        `"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`
      );
    }
  }
  return isConditionalSugar;
}
function throwExportsNotFound(subpath, packageJSONUrl, base) {
  throw new ERR_PACKAGE_PATH_NOT_EXPORTED(
    url.fileURLToPath(new URL(".", packageJSONUrl)),
    subpath,
    base && url.fileURLToPath(base)
  );
}
const emittedPackageWarnings = /* @__PURE__ */ new Set();
function emitTrailingSlashPatternDeprecation(match, pjsonUrl, base) {
  const pjsonPath = url.fileURLToPath(pjsonUrl);
  if (emittedPackageWarnings.has(pjsonPath + "|" + match))
    return;
  emittedPackageWarnings.add(pjsonPath + "|" + match);
  process.emitWarning(
    `Use of deprecated trailing slash pattern mapping "${match}" in the "exports" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${url.fileURLToPath(base)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`,
    "DeprecationWarning",
    "DEP0155"
  );
}
function packageExportsResolve({
  packageJSONUrl,
  packageSubpath,
  exports,
  base,
  conditions
}) {
  if (isConditionalExportsMainSugar(exports, packageJSONUrl, base))
    exports = { ".": exports };
  if (ObjectPrototypeHasOwnProperty(exports, packageSubpath) && !StringPrototypeIncludes(packageSubpath, "*") && !StringPrototypeEndsWith(packageSubpath, "/")) {
    const target = exports[packageSubpath];
    const resolveResult = resolvePackageTarget(
      packageJSONUrl,
      target,
      "",
      packageSubpath,
      base,
      false,
      false,
      conditions
    );
    if (resolveResult == null) {
      throwExportsNotFound(packageSubpath, packageJSONUrl, base);
    }
    return resolveResult;
  }
  let bestMatch = "";
  let bestMatchSubpath;
  const keys = ObjectGetOwnPropertyNames(exports);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    const patternIndex = StringPrototypeIndexOf(key, "*");
    if (patternIndex !== -1 && StringPrototypeStartsWith(
      packageSubpath,
      StringPrototypeSlice(key, 0, patternIndex)
    )) {
      if (StringPrototypeEndsWith(packageSubpath, "/"))
        emitTrailingSlashPatternDeprecation(
          packageSubpath,
          packageJSONUrl,
          base
        );
      const patternTrailer = StringPrototypeSlice(key, patternIndex + 1);
      if (packageSubpath.length >= key.length && StringPrototypeEndsWith(packageSubpath, patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && StringPrototypeLastIndexOf(key, "*") === patternIndex) {
        bestMatch = key;
        bestMatchSubpath = StringPrototypeSlice(
          packageSubpath,
          patternIndex,
          packageSubpath.length - patternTrailer.length
        );
      }
    }
  }
  if (bestMatch) {
    const target = exports[bestMatch];
    const resolveResult = resolvePackageTarget(
      packageJSONUrl,
      target,
      bestMatchSubpath,
      bestMatch,
      base,
      true,
      false,
      conditions
    );
    if (resolveResult == null) {
      throwExportsNotFound(packageSubpath, packageJSONUrl, base);
    }
    return resolveResult;
  }
  throwExportsNotFound(packageSubpath, packageJSONUrl, base);
}
function packageImportsResolve({ name, base, conditions, readFileSyncFn }) {
  if (name === "#" || StringPrototypeStartsWith(name, "#/") || StringPrototypeEndsWith(name, "/")) {
    const reason = "is not a valid internal imports specifier name";
    throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, url.fileURLToPath(base));
  }
  let packageJSONUrl;
  const packageConfig = getPackageScopeConfig(base, readFileSyncFn);
  if (packageConfig.exists) {
    packageJSONUrl = url.pathToFileURL(packageConfig.pjsonPath);
    const imports = packageConfig.imports;
    if (imports) {
      if (ObjectPrototypeHasOwnProperty(imports, name) && !StringPrototypeIncludes(name, "*")) {
        const resolveResult = resolvePackageTarget(
          packageJSONUrl,
          imports[name],
          "",
          name,
          base,
          false,
          true,
          conditions
        );
        if (resolveResult != null) {
          return resolveResult;
        }
      } else {
        let bestMatch = "";
        let bestMatchSubpath;
        const keys = ObjectGetOwnPropertyNames(imports);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const patternIndex = StringPrototypeIndexOf(key, "*");
          if (patternIndex !== -1 && StringPrototypeStartsWith(
            name,
            StringPrototypeSlice(key, 0, patternIndex)
          )) {
            const patternTrailer = StringPrototypeSlice(key, patternIndex + 1);
            if (name.length >= key.length && StringPrototypeEndsWith(name, patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && StringPrototypeLastIndexOf(key, "*") === patternIndex) {
              bestMatch = key;
              bestMatchSubpath = StringPrototypeSlice(
                name,
                patternIndex,
                name.length - patternTrailer.length
              );
            }
          }
        }
        if (bestMatch) {
          const target = imports[bestMatch];
          const resolveResult = resolvePackageTarget(
            packageJSONUrl,
            target,
            bestMatchSubpath,
            bestMatch,
            base,
            true,
            true,
            conditions
          );
          if (resolveResult != null) {
            return resolveResult;
          }
        }
      }
    }
  }
  throwImportNotDefined(name, packageJSONUrl, base);
}

var ErrorCode = /* @__PURE__ */ ((ErrorCode2) => {
  ErrorCode2["API_ERROR"] = `API_ERROR`;
  ErrorCode2["BUILTIN_NODE_RESOLUTION_FAILED"] = `BUILTIN_NODE_RESOLUTION_FAILED`;
  ErrorCode2["EXPORTS_RESOLUTION_FAILED"] = `EXPORTS_RESOLUTION_FAILED`;
  ErrorCode2["MISSING_DEPENDENCY"] = `MISSING_DEPENDENCY`;
  ErrorCode2["MISSING_PEER_DEPENDENCY"] = `MISSING_PEER_DEPENDENCY`;
  ErrorCode2["QUALIFIED_PATH_RESOLUTION_FAILED"] = `QUALIFIED_PATH_RESOLUTION_FAILED`;
  ErrorCode2["INTERNAL"] = `INTERNAL`;
  ErrorCode2["UNDECLARED_DEPENDENCY"] = `UNDECLARED_DEPENDENCY`;
  ErrorCode2["UNSUPPORTED"] = `UNSUPPORTED`;
  return ErrorCode2;
})(ErrorCode || {});
const MODULE_NOT_FOUND_ERRORS = /* @__PURE__ */ new Set([
  "BUILTIN_NODE_RESOLUTION_FAILED" /* BUILTIN_NODE_RESOLUTION_FAILED */,
  "MISSING_DEPENDENCY" /* MISSING_DEPENDENCY */,
  "MISSING_PEER_DEPENDENCY" /* MISSING_PEER_DEPENDENCY */,
  "QUALIFIED_PATH_RESOLUTION_FAILED" /* QUALIFIED_PATH_RESOLUTION_FAILED */,
  "UNDECLARED_DEPENDENCY" /* UNDECLARED_DEPENDENCY */
]);
function makeError(pnpCode, message, data = {}, code) {
  code ??= MODULE_NOT_FOUND_ERRORS.has(pnpCode) ? `MODULE_NOT_FOUND` : pnpCode;
  const propertySpec = {
    configurable: true,
    writable: true,
    enumerable: false
  };
  return Object.defineProperties(new Error(message), {
    code: {
      ...propertySpec,
      value: code
    },
    pnpCode: {
      ...propertySpec,
      value: pnpCode
    },
    data: {
      ...propertySpec,
      value: data
    }
  });
}
function getPathForDisplay(p) {
  return npath.normalize(npath.fromPortablePath(p));
}

const flagSymbol = Symbol('arg flag');

class ArgError extends Error {
	constructor(msg, code) {
		super(msg);
		this.name = 'ArgError';
		this.code = code;

		Object.setPrototypeOf(this, ArgError.prototype);
	}
}

function arg(
	opts,
	{
		argv = process.argv.slice(2),
		permissive = false,
		stopAtPositional = false
	} = {}
) {
	if (!opts) {
		throw new ArgError(
			'argument specification object is required',
			'ARG_CONFIG_NO_SPEC'
		);
	}

	const result = { _: [] };

	const aliases = {};
	const handlers = {};

	for (const key of Object.keys(opts)) {
		if (!key) {
			throw new ArgError(
				'argument key cannot be an empty string',
				'ARG_CONFIG_EMPTY_KEY'
			);
		}

		if (key[0] !== '-') {
			throw new ArgError(
				`argument key must start with '-' but found: '${key}'`,
				'ARG_CONFIG_NONOPT_KEY'
			);
		}

		if (key.length === 1) {
			throw new ArgError(
				`argument key must have a name; singular '-' keys are not allowed: ${key}`,
				'ARG_CONFIG_NONAME_KEY'
			);
		}

		if (typeof opts[key] === 'string') {
			aliases[key] = opts[key];
			continue;
		}

		let type = opts[key];
		let isFlag = false;

		if (
			Array.isArray(type) &&
			type.length === 1 &&
			typeof type[0] === 'function'
		) {
			const [fn] = type;
			type = (value, name, prev = []) => {
				prev.push(fn(value, name, prev[prev.length - 1]));
				return prev;
			};
			isFlag = fn === Boolean || fn[flagSymbol] === true;
		} else if (typeof type === 'function') {
			isFlag = type === Boolean || type[flagSymbol] === true;
		} else {
			throw new ArgError(
				`type missing or not a function or valid array type: ${key}`,
				'ARG_CONFIG_VAD_TYPE'
			);
		}

		if (key[1] !== '-' && key.length > 2) {
			throw new ArgError(
				`short argument keys (with a single hyphen) must have only one character: ${key}`,
				'ARG_CONFIG_SHORTOPT_TOOLONG'
			);
		}

		handlers[key] = [type, isFlag];
	}

	for (let i = 0, len = argv.length; i < len; i++) {
		const wholeArg = argv[i];

		if (stopAtPositional && result._.length > 0) {
			result._ = result._.concat(argv.slice(i));
			break;
		}

		if (wholeArg === '--') {
			result._ = result._.concat(argv.slice(i + 1));
			break;
		}

		if (wholeArg.length > 1 && wholeArg[0] === '-') {
			/* eslint-disable operator-linebreak */
			const separatedArguments =
				wholeArg[1] === '-' || wholeArg.length === 2
					? [wholeArg]
					: wholeArg
							.slice(1)
							.split('')
							.map((a) => `-${a}`);
			/* eslint-enable operator-linebreak */

			for (let j = 0; j < separatedArguments.length; j++) {
				const arg = separatedArguments[j];
				const [originalArgName, argStr] =
					arg[1] === '-' ? arg.split(/=(.*)/, 2) : [arg, undefined];

				let argName = originalArgName;
				while (argName in aliases) {
					argName = aliases[argName];
				}

				if (!(argName in handlers)) {
					if (permissive) {
						result._.push(arg);
						continue;
					} else {
						throw new ArgError(
							`unknown or unexpected option: ${originalArgName}`,
							'ARG_UNKNOWN_OPTION'
						);
					}
				}

				const [type, isFlag] = handlers[argName];

				if (!isFlag && j + 1 < separatedArguments.length) {
					throw new ArgError(
						`option requires argument (but was followed by another short argument): ${originalArgName}`,
						'ARG_MISSING_REQUIRED_SHORTARG'
					);
				}

				if (isFlag) {
					result[argName] = type(true, argName, result[argName]);
				} else if (argStr === undefined) {
					if (
						argv.length < i + 2 ||
						(argv[i + 1].length > 1 &&
							argv[i + 1][0] === '-' &&
							!(
								argv[i + 1].match(/^-?\d*(\.(?=\d))?\d*$/) &&
								(type === Number ||
									// eslint-disable-next-line no-undef
									(typeof BigInt !== 'undefined' && type === BigInt))
							))
					) {
						const extended =
							originalArgName === argName ? '' : ` (alias for ${argName})`;
						throw new ArgError(
							`option requires argument: ${originalArgName}${extended}`,
							'ARG_MISSING_REQUIRED_LONGARG'
						);
					}

					result[argName] = type(argv[i + 1], argName, result[argName]);
					++i;
				} else {
					result[argName] = type(argStr, argName, result[argName]);
				}
			}
		} else {
			result._.push(wholeArg);
		}
	}

	return result;
}

arg.flag = (fn) => {
	fn[flagSymbol] = true;
	return fn;
};

// Utility types
arg.COUNT = arg.flag((v, name, existingCount) => (existingCount || 0) + 1);

// Expose error class
arg.ArgError = ArgError;

var arg_1 = arg;

/**
  @license
  The MIT License (MIT)

  Copyright (c) 2014 Blake Embrey (hello@blakeembrey.com)

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
*/
function getOptionValue(opt) {
  parseOptions();
  return options[opt];
}
let options;
function parseOptions() {
  if (!options) {
    options = {
      "--conditions": [],
      ...parseArgv(getNodeOptionsEnvArgv()),
      ...parseArgv(process.execArgv)
    };
  }
}
function parseArgv(argv) {
  return arg_1(
    {
      "--conditions": [String],
      "-C": "--conditions"
    },
    {
      argv,
      permissive: true
    }
  );
}
function getNodeOptionsEnvArgv() {
  const errors = [];
  const envArgv = ParseNodeOptionsEnvVar(process.env.NODE_OPTIONS || "", errors);
  if (errors.length !== 0) ;
  return envArgv;
}
function ParseNodeOptionsEnvVar(node_options, errors) {
  const env_argv = [];
  let is_in_string = false;
  let will_start_new_arg = true;
  for (let index = 0; index < node_options.length; ++index) {
    let c = node_options[index];
    if (c === "\\" && is_in_string) {
      if (index + 1 === node_options.length) {
        errors.push("invalid value for NODE_OPTIONS (invalid escape)\n");
        return env_argv;
      } else {
        c = node_options[++index];
      }
    } else if (c === " " && !is_in_string) {
      will_start_new_arg = true;
      continue;
    } else if (c === '"') {
      is_in_string = !is_in_string;
      continue;
    }
    if (will_start_new_arg) {
      env_argv.push(c);
      will_start_new_arg = false;
    } else {
      env_argv[env_argv.length - 1] += c;
    }
  }
  if (is_in_string) {
    errors.push("invalid value for NODE_OPTIONS (unterminated string)\n");
  }
  return env_argv;
}

const [major, minor] = process.versions.node.split(`.`).map((value) => parseInt(value, 10));
const WATCH_MODE_MESSAGE_USES_ARRAYS = major > 19 || major === 19 && minor >= 2 || major === 18 && minor >= 13;

function reportRequiredFilesToWatchMode(files) {
  if (process.env.WATCH_REPORT_DEPENDENCIES && process.send) {
    files = files.map((filename) => npath.fromPortablePath(VirtualFS.resolveVirtual(npath.toPortablePath(filename))));
    if (WATCH_MODE_MESSAGE_USES_ARRAYS) {
      process.send({ "watch:require": files });
    } else {
      for (const filename of files) {
        process.send({ "watch:require": filename });
      }
    }
  }
}

function makeApi(runtimeState, opts) {
  const alwaysWarnOnFallback = Number(process.env.PNP_ALWAYS_WARN_ON_FALLBACK) > 0;
  const debugLevel = Number(process.env.PNP_DEBUG_LEVEL);
  const pathRegExp = /^(?![a-zA-Z]:[\\/]|\\\\|\.{0,2}(?:\/|$))((?:node:)?(?:@[^/]+\/)?[^/]+)\/*(.*|)$/;
  const isStrictRegExp = /^(\/|\.{1,2}(\/|$))/;
  const isDirRegExp = /\/$/;
  const isRelativeRegexp = /^\.{0,2}\//;
  const topLevelLocator = { name: null, reference: null };
  const fallbackLocators = [];
  const emittedWarnings = /* @__PURE__ */ new Set();
  if (runtimeState.enableTopLevelFallback === true)
    fallbackLocators.push(topLevelLocator);
  if (opts.compatibilityMode !== false) {
    for (const name of [`react-scripts`, `gatsby`]) {
      const packageStore = runtimeState.packageRegistry.get(name);
      if (packageStore) {
        for (const reference of packageStore.keys()) {
          if (reference === null) {
            throw new Error(`Assertion failed: This reference shouldn't be null`);
          } else {
            fallbackLocators.push({ name, reference });
          }
        }
      }
    }
  }
  const {
    ignorePattern,
    packageRegistry,
    packageLocatorsByLocations
  } = runtimeState;
  function makeLogEntry(name, args) {
    return {
      fn: name,
      args,
      error: null,
      result: null
    };
  }
  function trace(entry) {
    const colors = process.stderr?.hasColors?.() ?? process.stdout.isTTY;
    const c = (n, str) => `\x1B[${n}m${str}\x1B[0m`;
    const error = entry.error;
    if (error)
      console.error(c(`31;1`, `\u2716 ${entry.error?.message.replace(/\n.*/s, ``)}`));
    else
      console.error(c(`33;1`, `\u203C Resolution`));
    if (entry.args.length > 0)
      console.error();
    for (const arg of entry.args)
      console.error(`  ${c(`37;1`, `In \u2190`)} ${nodeUtils.inspect(arg, { colors, compact: true })}`);
    if (entry.result) {
      console.error();
      console.error(`  ${c(`37;1`, `Out \u2192`)} ${nodeUtils.inspect(entry.result, { colors, compact: true })}`);
    }
    const stack = new Error().stack.match(/(?<=^ +)at.*/gm)?.slice(2) ?? [];
    if (stack.length > 0) {
      console.error();
      for (const line of stack) {
        console.error(`  ${c(`38;5;244`, line)}`);
      }
    }
    console.error();
  }
  function maybeLog(name, fn) {
    if (opts.allowDebug === false)
      return fn;
    if (Number.isFinite(debugLevel)) {
      if (debugLevel >= 2) {
        return (...args) => {
          const logEntry = makeLogEntry(name, args);
          try {
            return logEntry.result = fn(...args);
          } catch (error) {
            throw logEntry.error = error;
          } finally {
            trace(logEntry);
          }
        };
      } else if (debugLevel >= 1) {
        return (...args) => {
          try {
            return fn(...args);
          } catch (error) {
            const logEntry = makeLogEntry(name, args);
            logEntry.error = error;
            trace(logEntry);
            throw error;
          }
        };
      }
    }
    return fn;
  }
  function getPackageInformationSafe(packageLocator) {
    const packageInformation = getPackageInformation(packageLocator);
    if (!packageInformation) {
      throw makeError(
        ErrorCode.INTERNAL,
        `Couldn't find a matching entry in the dependency tree for the specified parent (this is probably an internal error)`
      );
    }
    return packageInformation;
  }
  function isDependencyTreeRoot(packageLocator) {
    if (packageLocator.name === null)
      return true;
    for (const dependencyTreeRoot of runtimeState.dependencyTreeRoots)
      if (dependencyTreeRoot.name === packageLocator.name && dependencyTreeRoot.reference === packageLocator.reference)
        return true;
    return false;
  }
  const defaultExportsConditions = /* @__PURE__ */ new Set([
    `node`,
    `require`,
    ...getOptionValue(`--conditions`)
  ]);
  function applyNodeExportsResolution(unqualifiedPath, conditions = defaultExportsConditions, issuer) {
    const locator = findPackageLocator(ppath.join(unqualifiedPath, `internal.js`), {
      resolveIgnored: true,
      includeDiscardFromLookup: true
    });
    if (locator === null) {
      throw makeError(
        ErrorCode.INTERNAL,
        `The locator that owns the "${unqualifiedPath}" path can't be found inside the dependency tree (this is probably an internal error)`
      );
    }
    const { packageLocation } = getPackageInformationSafe(locator);
    const manifestPath = ppath.join(packageLocation, Filename.manifest);
    if (!opts.fakeFs.existsSync(manifestPath))
      return null;
    const pkgJson = JSON.parse(opts.fakeFs.readFileSync(manifestPath, `utf8`));
    if (pkgJson.exports == null)
      return null;
    let subpath = ppath.contains(packageLocation, unqualifiedPath);
    if (subpath === null) {
      throw makeError(
        ErrorCode.INTERNAL,
        `unqualifiedPath doesn't contain the packageLocation (this is probably an internal error)`
      );
    }
    if (subpath !== `.` && !isRelativeRegexp.test(subpath))
      subpath = `./${subpath}`;
    try {
      const resolvedExport = packageExportsResolve({
        packageJSONUrl: url.pathToFileURL(npath.fromPortablePath(manifestPath)),
        packageSubpath: subpath,
        exports: pkgJson.exports,
        base: issuer ? url.pathToFileURL(npath.fromPortablePath(issuer)) : null,
        conditions
      });
      return npath.toPortablePath(url.fileURLToPath(resolvedExport));
    } catch (error) {
      throw makeError(
        ErrorCode.EXPORTS_RESOLUTION_FAILED,
        error.message,
        { unqualifiedPath: getPathForDisplay(unqualifiedPath), locator, pkgJson, subpath: getPathForDisplay(subpath), conditions },
        error.code
      );
    }
  }
  function applyNodeExtensionResolution(unqualifiedPath, candidates, { extensions }) {
    let stat;
    try {
      candidates.push(unqualifiedPath);
      stat = opts.fakeFs.statSync(unqualifiedPath);
    } catch (error) {
    }
    if (stat && !stat.isDirectory())
      return opts.fakeFs.realpathSync(unqualifiedPath);
    if (stat && stat.isDirectory()) {
      let pkgJson;
      try {
        pkgJson = JSON.parse(opts.fakeFs.readFileSync(ppath.join(unqualifiedPath, Filename.manifest), `utf8`));
      } catch (error) {
      }
      let nextUnqualifiedPath;
      if (pkgJson && pkgJson.main)
        nextUnqualifiedPath = ppath.resolve(unqualifiedPath, pkgJson.main);
      if (nextUnqualifiedPath && nextUnqualifiedPath !== unqualifiedPath) {
        const resolution = applyNodeExtensionResolution(nextUnqualifiedPath, candidates, { extensions });
        if (resolution !== null) {
          return resolution;
        }
      }
    }
    for (let i = 0, length = extensions.length; i < length; i++) {
      const candidateFile = `${unqualifiedPath}${extensions[i]}`;
      candidates.push(candidateFile);
      if (opts.fakeFs.existsSync(candidateFile)) {
        return candidateFile;
      }
    }
    if (stat && stat.isDirectory()) {
      for (let i = 0, length = extensions.length; i < length; i++) {
        const candidateFile = ppath.format({ dir: unqualifiedPath, name: `index`, ext: extensions[i] });
        candidates.push(candidateFile);
        if (opts.fakeFs.existsSync(candidateFile)) {
          return candidateFile;
        }
      }
    }
    return null;
  }
  function makeFakeModule(path) {
    const fakeModule = new module$1.Module(path, null);
    fakeModule.filename = path;
    fakeModule.paths = module$1.Module._nodeModulePaths(path);
    return fakeModule;
  }
  function callNativeResolution(request, issuer) {
    if (issuer.endsWith(`/`))
      issuer = ppath.join(issuer, `internal.js`);
    return module$1.Module._resolveFilename(npath.fromPortablePath(request), makeFakeModule(npath.fromPortablePath(issuer)), false, { plugnplay: false });
  }
  function isPathIgnored(path) {
    if (ignorePattern === null)
      return false;
    const subPath = ppath.contains(runtimeState.basePath, path);
    if (subPath === null)
      return false;
    if (ignorePattern.test(subPath.replace(/\/$/, ``))) {
      return true;
    } else {
      return false;
    }
  }
  const VERSIONS = { std: 3, resolveVirtual: 1, getAllLocators: 1 };
  const topLevel = topLevelLocator;
  function getPackageInformation({ name, reference }) {
    const packageInformationStore = packageRegistry.get(name);
    if (!packageInformationStore)
      return null;
    const packageInformation = packageInformationStore.get(reference);
    if (!packageInformation)
      return null;
    return packageInformation;
  }
  function findPackageDependents({ name, reference }) {
    const dependents = [];
    for (const [dependentName, packageInformationStore] of packageRegistry) {
      if (dependentName === null)
        continue;
      for (const [dependentReference, packageInformation] of packageInformationStore) {
        if (dependentReference === null)
          continue;
        const dependencyReference = packageInformation.packageDependencies.get(name);
        if (dependencyReference !== reference)
          continue;
        if (dependentName === name && dependentReference === reference)
          continue;
        dependents.push({
          name: dependentName,
          reference: dependentReference
        });
      }
    }
    return dependents;
  }
  function findBrokenPeerDependencies(dependency, initialPackage) {
    const brokenPackages = /* @__PURE__ */ new Map();
    const alreadyVisited = /* @__PURE__ */ new Set();
    const traversal = (currentPackage) => {
      const identifier = JSON.stringify(currentPackage.name);
      if (alreadyVisited.has(identifier))
        return;
      alreadyVisited.add(identifier);
      const dependents = findPackageDependents(currentPackage);
      for (const dependent of dependents) {
        const dependentInformation = getPackageInformationSafe(dependent);
        if (dependentInformation.packagePeers.has(dependency)) {
          traversal(dependent);
        } else {
          let brokenSet = brokenPackages.get(dependent.name);
          if (typeof brokenSet === `undefined`)
            brokenPackages.set(dependent.name, brokenSet = /* @__PURE__ */ new Set());
          brokenSet.add(dependent.reference);
        }
      }
    };
    traversal(initialPackage);
    const brokenList = [];
    for (const name of [...brokenPackages.keys()].sort())
      for (const reference of [...brokenPackages.get(name)].sort())
        brokenList.push({ name, reference });
    return brokenList;
  }
  function findPackageLocator(location, { resolveIgnored = false, includeDiscardFromLookup = false } = {}) {
    if (isPathIgnored(location) && !resolveIgnored)
      return null;
    let relativeLocation = ppath.relative(runtimeState.basePath, location);
    if (!relativeLocation.match(isStrictRegExp))
      relativeLocation = `./${relativeLocation}`;
    if (!relativeLocation.endsWith(`/`))
      relativeLocation = `${relativeLocation}/`;
    do {
      const entry = packageLocatorsByLocations.get(relativeLocation);
      if (typeof entry === `undefined` || entry.discardFromLookup && !includeDiscardFromLookup) {
        relativeLocation = relativeLocation.substring(0, relativeLocation.lastIndexOf(`/`, relativeLocation.length - 2) + 1);
        continue;
      }
      return entry.locator;
    } while (relativeLocation !== ``);
    return null;
  }
  function tryReadFile(filePath) {
    try {
      return opts.fakeFs.readFileSync(npath.toPortablePath(filePath), `utf8`);
    } catch (err) {
      if (err.code === `ENOENT`)
        return void 0;
      throw err;
    }
  }
  function resolveToUnqualified(request, issuer, { considerBuiltins = true } = {}) {
    if (request.startsWith(`#`))
      throw new Error(`resolveToUnqualified can not handle private import mappings`);
    if (request === `pnpapi`)
      return npath.toPortablePath(opts.pnpapiResolution);
    if (considerBuiltins && module$1.isBuiltin(request))
      return null;
    const requestForDisplay = getPathForDisplay(request);
    const issuerForDisplay = issuer && getPathForDisplay(issuer);
    if (issuer && isPathIgnored(issuer)) {
      if (!ppath.isAbsolute(request) || findPackageLocator(request) === null) {
        const result = callNativeResolution(request, issuer);
        if (result === false) {
          throw makeError(
            ErrorCode.BUILTIN_NODE_RESOLUTION_FAILED,
            `The builtin node resolution algorithm was unable to resolve the requested module (it didn't go through the pnp resolver because the issuer was explicitely ignored by the regexp)

Require request: "${requestForDisplay}"
Required by: ${issuerForDisplay}
`,
            { request: requestForDisplay, issuer: issuerForDisplay }
          );
        }
        return npath.toPortablePath(result);
      }
    }
    let unqualifiedPath;
    const dependencyNameMatch = request.match(pathRegExp);
    if (!dependencyNameMatch) {
      if (ppath.isAbsolute(request)) {
        unqualifiedPath = ppath.normalize(request);
      } else {
        if (!issuer) {
          throw makeError(
            ErrorCode.API_ERROR,
            `The resolveToUnqualified function must be called with a valid issuer when the path isn't a builtin nor absolute`,
            { request: requestForDisplay, issuer: issuerForDisplay }
          );
        }
        const absoluteIssuer = ppath.resolve(issuer);
        if (issuer.match(isDirRegExp)) {
          unqualifiedPath = ppath.normalize(ppath.join(absoluteIssuer, request));
        } else {
          unqualifiedPath = ppath.normalize(ppath.join(ppath.dirname(absoluteIssuer), request));
        }
      }
    } else {
      if (!issuer) {
        throw makeError(
          ErrorCode.API_ERROR,
          `The resolveToUnqualified function must be called with a valid issuer when the path isn't a builtin nor absolute`,
          { request: requestForDisplay, issuer: issuerForDisplay }
        );
      }
      const [, dependencyName, subPath] = dependencyNameMatch;
      const issuerLocator = findPackageLocator(issuer);
      if (!issuerLocator) {
        const result = callNativeResolution(request, issuer);
        if (result === false) {
          throw makeError(
            ErrorCode.BUILTIN_NODE_RESOLUTION_FAILED,
            `The builtin node resolution algorithm was unable to resolve the requested module (it didn't go through the pnp resolver because the issuer doesn't seem to be part of the Yarn-managed dependency tree).

Require path: "${requestForDisplay}"
Required by: ${issuerForDisplay}
`,
            { request: requestForDisplay, issuer: issuerForDisplay }
          );
        }
        return npath.toPortablePath(result);
      }
      const issuerInformation = getPackageInformationSafe(issuerLocator);
      let dependencyReference = issuerInformation.packageDependencies.get(dependencyName);
      let fallbackReference = null;
      if (dependencyReference == null) {
        if (issuerLocator.name !== null) {
          const exclusionEntry = runtimeState.fallbackExclusionList.get(issuerLocator.name);
          const canUseFallbacks = !exclusionEntry || !exclusionEntry.has(issuerLocator.reference);
          if (canUseFallbacks) {
            for (let t = 0, T = fallbackLocators.length; t < T; ++t) {
              const fallbackInformation = getPackageInformationSafe(fallbackLocators[t]);
              const reference = fallbackInformation.packageDependencies.get(dependencyName);
              if (reference == null)
                continue;
              if (alwaysWarnOnFallback)
                fallbackReference = reference;
              else
                dependencyReference = reference;
              break;
            }
            if (runtimeState.enableTopLevelFallback) {
              if (dependencyReference == null && fallbackReference === null) {
                const reference = runtimeState.fallbackPool.get(dependencyName);
                if (reference != null) {
                  fallbackReference = reference;
                }
              }
            }
          }
        }
      }
      let error = null;
      if (dependencyReference === null) {
        if (isDependencyTreeRoot(issuerLocator)) {
          error = makeError(
            ErrorCode.MISSING_PEER_DEPENDENCY,
            `Your application tried to access ${dependencyName} (a peer dependency); this isn't allowed as there is no ancestor to satisfy the requirement. Use a devDependency if needed.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerForDisplay}
`,
            { request: requestForDisplay, issuer: issuerForDisplay, dependencyName }
          );
        } else {
          const brokenAncestors = findBrokenPeerDependencies(dependencyName, issuerLocator);
          if (brokenAncestors.every((ancestor) => isDependencyTreeRoot(ancestor))) {
            error = makeError(
              ErrorCode.MISSING_PEER_DEPENDENCY,
              `${issuerLocator.name} tried to access ${dependencyName} (a peer dependency) but it isn't provided by your application; this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})
${brokenAncestors.map((ancestorLocator) => `Ancestor breaking the chain: ${ancestorLocator.name}@${ancestorLocator.reference}
`).join(``)}
`,
              { request: requestForDisplay, issuer: issuerForDisplay, issuerLocator: Object.assign({}, issuerLocator), dependencyName, brokenAncestors }
            );
          } else {
            error = makeError(
              ErrorCode.MISSING_PEER_DEPENDENCY,
              `${issuerLocator.name} tried to access ${dependencyName} (a peer dependency) but it isn't provided by its ancestors; this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})

${brokenAncestors.map((ancestorLocator) => `Ancestor breaking the chain: ${ancestorLocator.name}@${ancestorLocator.reference}
`).join(``)}
`,
              { request: requestForDisplay, issuer: issuerForDisplay, issuerLocator: Object.assign({}, issuerLocator), dependencyName, brokenAncestors }
            );
          }
        }
      } else if (dependencyReference === void 0) {
        if (!considerBuiltins && module$1.isBuiltin(request)) {
          if (isDependencyTreeRoot(issuerLocator)) {
            error = makeError(
              ErrorCode.UNDECLARED_DEPENDENCY,
              `Your application tried to access ${dependencyName}. While this module is usually interpreted as a Node builtin, your resolver is running inside a non-Node resolution context where such builtins are ignored. Since ${dependencyName} isn't otherwise declared in your dependencies, this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerForDisplay}
`,
              { request: requestForDisplay, issuer: issuerForDisplay, dependencyName }
            );
          } else {
            error = makeError(
              ErrorCode.UNDECLARED_DEPENDENCY,
              `${issuerLocator.name} tried to access ${dependencyName}. While this module is usually interpreted as a Node builtin, your resolver is running inside a non-Node resolution context where such builtins are ignored. Since ${dependencyName} isn't otherwise declared in ${issuerLocator.name}'s dependencies, this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerForDisplay}
`,
              { request: requestForDisplay, issuer: issuerForDisplay, issuerLocator: Object.assign({}, issuerLocator), dependencyName }
            );
          }
        } else {
          if (isDependencyTreeRoot(issuerLocator)) {
            error = makeError(
              ErrorCode.UNDECLARED_DEPENDENCY,
              `Your application tried to access ${dependencyName}, but it isn't declared in your dependencies; this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerForDisplay}
`,
              { request: requestForDisplay, issuer: issuerForDisplay, dependencyName }
            );
          } else {
            error = makeError(
              ErrorCode.UNDECLARED_DEPENDENCY,
              `${issuerLocator.name} tried to access ${dependencyName}, but it isn't declared in its dependencies; this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})
`,
              { request: requestForDisplay, issuer: issuerForDisplay, issuerLocator: Object.assign({}, issuerLocator), dependencyName }
            );
          }
        }
      }
      if (dependencyReference == null) {
        if (fallbackReference === null || error === null)
          throw error || new Error(`Assertion failed: Expected an error to have been set`);
        dependencyReference = fallbackReference;
        const message = error.message.replace(/\n.*/g, ``);
        error.message = message;
        if (!emittedWarnings.has(message) && debugLevel !== 0) {
          emittedWarnings.add(message);
          process.emitWarning(error);
        }
      }
      const dependencyLocator = Array.isArray(dependencyReference) ? { name: dependencyReference[0], reference: dependencyReference[1] } : { name: dependencyName, reference: dependencyReference };
      const dependencyInformation = getPackageInformationSafe(dependencyLocator);
      if (!dependencyInformation.packageLocation) {
        throw makeError(
          ErrorCode.MISSING_DEPENDENCY,
          `A dependency seems valid but didn't get installed for some reason. This might be caused by a partial install, such as dev vs prod.

Required package: ${dependencyLocator.name}@${dependencyLocator.reference}${dependencyLocator.name !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})
`,
          { request: requestForDisplay, issuer: issuerForDisplay, dependencyLocator: Object.assign({}, dependencyLocator) }
        );
      }
      const dependencyLocation = dependencyInformation.packageLocation;
      if (subPath) {
        unqualifiedPath = ppath.join(dependencyLocation, subPath);
      } else {
        unqualifiedPath = dependencyLocation;
      }
    }
    return ppath.normalize(unqualifiedPath);
  }
  function resolveUnqualifiedExport(request, unqualifiedPath, conditions = defaultExportsConditions, issuer) {
    if (isStrictRegExp.test(request))
      return unqualifiedPath;
    const unqualifiedExportPath = applyNodeExportsResolution(unqualifiedPath, conditions, issuer);
    if (unqualifiedExportPath) {
      return ppath.normalize(unqualifiedExportPath);
    } else {
      return unqualifiedPath;
    }
  }
  function resolveUnqualified(unqualifiedPath, { extensions = Object.keys(module$1.Module._extensions) } = {}) {
    const candidates = [];
    const qualifiedPath = applyNodeExtensionResolution(unqualifiedPath, candidates, { extensions });
    if (qualifiedPath) {
      return ppath.normalize(qualifiedPath);
    } else {
      reportRequiredFilesToWatchMode(candidates.map((candidate) => npath.fromPortablePath(candidate)));
      const unqualifiedPathForDisplay = getPathForDisplay(unqualifiedPath);
      const containingPackage = findPackageLocator(unqualifiedPath);
      if (containingPackage) {
        const { packageLocation } = getPackageInformationSafe(containingPackage);
        let exists = true;
        try {
          opts.fakeFs.accessSync(packageLocation);
        } catch (err) {
          if (err?.code === `ENOENT`) {
            exists = false;
          } else {
            const readableError = (err?.message ?? err ?? `empty exception thrown`).replace(/^[A-Z]/, ($0) => $0.toLowerCase());
            throw makeError(ErrorCode.QUALIFIED_PATH_RESOLUTION_FAILED, `Required package exists but could not be accessed (${readableError}).

Missing package: ${containingPackage.name}@${containingPackage.reference}
Expected package location: ${getPathForDisplay(packageLocation)}
`, { unqualifiedPath: unqualifiedPathForDisplay, extensions });
          }
        }
        if (!exists) {
          const errorMessage = packageLocation.includes(`/unplugged/`) ? `Required unplugged package missing from disk. This may happen when switching branches without running installs (unplugged packages must be fully materialized on disk to work).` : `Required package missing from disk. If you keep your packages inside your repository then restarting the Node process may be enough. Otherwise, try to run an install first.`;
          throw makeError(
            ErrorCode.QUALIFIED_PATH_RESOLUTION_FAILED,
            `${errorMessage}

Missing package: ${containingPackage.name}@${containingPackage.reference}
Expected package location: ${getPathForDisplay(packageLocation)}
`,
            { unqualifiedPath: unqualifiedPathForDisplay, extensions }
          );
        }
      }
      throw makeError(
        ErrorCode.QUALIFIED_PATH_RESOLUTION_FAILED,
        `Qualified path resolution failed: we looked for the following paths, but none could be accessed.

Source path: ${unqualifiedPathForDisplay}
${candidates.map((candidate) => `Not found: ${getPathForDisplay(candidate)}
`).join(``)}`,
        { unqualifiedPath: unqualifiedPathForDisplay, extensions }
      );
    }
  }
  function resolvePrivateRequest(request, issuer, opts2) {
    if (!issuer)
      throw new Error(`Assertion failed: An issuer is required to resolve private import mappings`);
    const resolved = packageImportsResolve({
      name: request,
      base: url.pathToFileURL(npath.fromPortablePath(issuer)),
      conditions: opts2.conditions ?? defaultExportsConditions,
      readFileSyncFn: tryReadFile
    });
    if (resolved instanceof URL) {
      return resolveUnqualified(npath.toPortablePath(url.fileURLToPath(resolved)), { extensions: opts2.extensions });
    } else {
      if (resolved.startsWith(`#`))
        throw new Error(`Mapping from one private import to another isn't allowed`);
      return resolveRequest(resolved, issuer, opts2);
    }
  }
  function resolveRequest(request, issuer, opts2 = {}) {
    try {
      if (request.startsWith(`#`))
        return resolvePrivateRequest(request, issuer, opts2);
      const { considerBuiltins, extensions, conditions } = opts2;
      const unqualifiedPath = resolveToUnqualified(request, issuer, { considerBuiltins });
      if (request === `pnpapi`)
        return unqualifiedPath;
      if (unqualifiedPath === null)
        return null;
      const isIssuerIgnored = () => issuer !== null ? isPathIgnored(issuer) : false;
      const remappedPath = (!considerBuiltins || !module$1.isBuiltin(request)) && !isIssuerIgnored() ? resolveUnqualifiedExport(request, unqualifiedPath, conditions, issuer) : unqualifiedPath;
      return resolveUnqualified(remappedPath, { extensions });
    } catch (error) {
      if (Object.hasOwn(error, `pnpCode`))
        Object.assign(error.data, { request: getPathForDisplay(request), issuer: issuer && getPathForDisplay(issuer) });
      throw error;
    }
  }
  function resolveVirtual(request) {
    const normalized = ppath.normalize(request);
    const resolved = VirtualFS.resolveVirtual(normalized);
    return resolved !== normalized ? resolved : null;
  }
  return {
    VERSIONS,
    topLevel,
    getLocator: (name, referencish) => {
      if (Array.isArray(referencish)) {
        return { name: referencish[0], reference: referencish[1] };
      } else {
        return { name, reference: referencish };
      }
    },
    getDependencyTreeRoots: () => {
      return [...runtimeState.dependencyTreeRoots];
    },
    getAllLocators() {
      const locators = [];
      for (const [name, entry] of packageRegistry)
        for (const reference of entry.keys())
          if (name !== null && reference !== null)
            locators.push({ name, reference });
      return locators;
    },
    getPackageInformation: (locator) => {
      const info = getPackageInformation(locator);
      if (info === null)
        return null;
      const packageLocation = npath.fromPortablePath(info.packageLocation);
      const nativeInfo = { ...info, packageLocation };
      return nativeInfo;
    },
    findPackageLocator: (path) => {
      return findPackageLocator(npath.toPortablePath(path));
    },
    resolveToUnqualified: maybeLog(`resolveToUnqualified`, (request, issuer, opts2) => {
      const portableIssuer = issuer !== null ? npath.toPortablePath(issuer) : null;
      const resolution = resolveToUnqualified(npath.toPortablePath(request), portableIssuer, opts2);
      if (resolution === null)
        return null;
      return npath.fromPortablePath(resolution);
    }),
    resolveUnqualified: maybeLog(`resolveUnqualified`, (unqualifiedPath, opts2) => {
      return npath.fromPortablePath(resolveUnqualified(npath.toPortablePath(unqualifiedPath), opts2));
    }),
    resolveRequest: maybeLog(`resolveRequest`, (request, issuer, opts2) => {
      const portableIssuer = issuer !== null ? npath.toPortablePath(issuer) : null;
      const resolution = resolveRequest(npath.toPortablePath(request), portableIssuer, opts2);
      if (resolution === null)
        return null;
      return npath.fromPortablePath(resolution);
    }),
    resolveVirtual: maybeLog(`resolveVirtual`, (path) => {
      const result = resolveVirtual(npath.toPortablePath(path));
      if (result !== null) {
        return npath.fromPortablePath(result);
      } else {
        return null;
      }
    })
  };
}

async function hydratePnpFile(location, { fakeFs, pnpapiResolution }) {
  const source = await fakeFs.readFilePromise(location, `utf8`);
  return hydratePnpSource(source, {
    basePath: path.dirname(location),
    fakeFs,
    pnpapiResolution
  });
}
function hydratePnpSource(source, { basePath, fakeFs, pnpapiResolution }) {
  const data = JSON.parse(source);
  const runtimeState = hydrateRuntimeState(data, {
    basePath
  });
  return makeApi(runtimeState, {
    compatibilityMode: true,
    fakeFs,
    pnpapiResolution
  });
}

const makeRuntimeApi = (settings, basePath, fakeFs) => {
  const data = generateSerializedState(settings);
  const state = hydrateRuntimeState(data, { basePath });
  const pnpapiResolution = npath.join(basePath, Filename.pnpCjs);
  return makeApi(state, { fakeFs, pnpapiResolution });
};

let hook;
var builtLoader = () => {
  if (typeof hook === `undefined`)
    hook = require$$0__default.default.brotliDecompressSync(Buffer.from("W/EOIYqK1huNipK+mgSsCngyavgDRdSqkdyEUbgrAd2m+vmsi/JxBrjDipj+mqlpvZpqozAKV1aAqDXHw/zPXSX4zOr+D5T/7dX8f/18nXUavNzVvlKt9OKU6tE8YXNlEyNguDi7ygTqP27+hFa/ps1FnP/Z1O65nBYtQ2SqSLrGz9pSOp7sF0UxrpoFtgl8e932v0zBrDJynSwtmnLJL2IPXeFNrWl1rOCB8Usk03gIgdauN0zn9++XpopsQDxy5JM7tKNgZg8SOVQUsavuq3vQC1pEAw0PQAizYcYrR+vyqur9j+4GxNMgOcfgkFrobd+yeGKFCiOQXrPYFq39mxcRnnyUyUztVOAAQJnXVB3cf0zCkBFi3x0bd/A/1+Y0qpnVAN7vcGl/TPvnXWu7bykJEKa4QuT//SHze27O3p9O77YWQggBQghou39mMq1RDvP31K9YK8sEU9bhCjJRQzPb8BOOjVzrmhE7DmFhR8vXq92Y2HHQd/y/MqJipJvv46OPPZqQHA/Zn1VZGSd/OvQwqxQhGfgvU+U5lahw7XGNfPFgOtiqHFbS1xxaWT5q3wUQKKvAyh5WigIMGLTtZsvsIiXWIeQh8pfAmcdc2X8osAXgxOb/OoBrgBxjWSItQwPYv68JnFpuP5RSU18su/sEDodEK82QEdta2YuzH9GmKO4CVkx/frs9twCugQ9uKsO3FPSsxNEW/f/5KPTHhT/kkMJxoY/2W1Yo7yOkHjvdglwz5tGIOjBHieXEsEdtmobYkegrCncAhDbKYpiDBRGrAMvcydJ0VCux84TPUnxcUck09tdRgmC46AROKv5oajYA16sDaqwOd7MIyc9Kk/6jPhTnhRjxmPXR3DrkGKAGIjl41f1gNVp1uZcSVc36+CmUA66dQr7Q2Eg8oSkbnpyFSwiRFV6F9HXhpAGBCb9ejKDKPmYl8g6Bk6imC3CDtJrSqYLikmpWR3PrJWXR8fNV71zTcMoJJv7ERo6U2oqa8OfdoZ/fwt2KLJqH4Kd6jDZ28h+B7FUs9On/u6fn21JCBgX5MX2WHGAfbmoal+LczxxfxjF3dm3VqhXy8FfYandfHcvNPJ7a1IXm4adAuXul80/1XGAVaL10B/qVqzHm/DGIeM2Sn0mNWjzWAxKgm+xhYQRPofid3tkXqNGuzQ2y11pwZF7DD0JBG/JrUyBRmZW+cVK1mMx5VA0A9neVSn+/qb4hvUcl60ba30sfexjWYblmQz3BWUqmKDiVTFx8IkBypw/N72+QBkdQf12s5eJ1z+9ddBJfOjr7IK7oflLHcnZJ1fJOF2BUG1G6W/qWuswPgsRTsmnBDuGmN9weKn8haku6GNyUx/YjesHKOpuXVoDW1ZDoFla1DSQ8ecdXoWPkVqOkYWe3JQVnKnFJHEjalI8iQkrLdhtH9bsSqH41IfL+Azsvj7wUYN1hu+PvRZLRtnod+b00/5Xiq4XZrUdWrzI6TB9RZEgGXFiAA6vURdspdhEgn9lWwbWru+kEEzrGKRDJIcFBDeSmzayv+3oo+m0PjlI+Dhz0pB3D3bevYYKIzlpJLU2LbeVwuqSx+XLrAeJA0poQon7LSzGF4i6OxB6eArJ90nSwLievTSQdcNJc8TcR30fDDotdUMTvUo8pSOWDt55OySuqLRKh7kB4I09szyVh7ASVgzRIp/y5WTs7YauOxijP7QeMdL+ckRxOc0fUUCwCcbpaVLEphHqpNf5hLD6lnUxS3BNlZebmCN6sXlZMckt3SvWfg5yXsmcnxn4Bxfag4qrqkuELx60Z90hDioYWEBBAGK38yfx0VbNHjY9V26WtL6ugWB9yBjHJWBrhtc/j1skOTM9mS2dTtEO2AXEdYPTRIx1D34kYJlGWqjV6SGE0bMpyCMAY8TxdfKSt30tU1P0T54Y5mXfcVnHSS4QGOlHpPOYP49IE9bKfKKPzSlgP+uQxvfypqEUzLQruy/yyU0TUV/dXlkAnVebU7CMxt9Fws9sCZegJRTKiTbbLSDMdj/arGjBWeByzyBZ/Ia84j0gzuy25cOG2IKBh6YbqnHt+Qf1cTUQWkXTQ/UEREtRZY18lZRXaMpUyUgoHfFP2aMToiUtcdM6q3JMoOQdMlo9DgPMxYlOKumh7n7G6sd3L81seQsfITauUac6SCslVAqKoFLYvrSNVDbsKDtkNLoOSfmTxKb3OD8NZqxViFB6zAhXopan+bd4HDDp4vp6wKDIXis5WFc71+4XMZ0Q9TXqoebOPKpFDbHHJ1WZev+y4wVWO+4Cjdv5HjNoveHcMc6+AAJqz+I7DHjrGrD6ZHo675jkvSARdLa+SC+Xe6HTXPIqeMyh6BzBgGmX4PULLc9O0Ci/FXiSWeUTTz+hlX6LyFyPVXBpLOe5eoWRdTT5IP+LG0rEWpGTUOIjgpWEd1VhiIy8ujQxdlt5l+bbGmfSI+OQGHmfovJp4xTb6IiWJc5pmPl1DHadPSjy9AgZXngXBv7jVe2F6oOM4/wlHMaUL2iKWzBkV5Gg3zXi3QmOJGwh+uhUN5c3Dj84II49DeX+BiEeuoQTX2rEV52nt1TuQ44Q0MzaboNzp0N8a/dib3w5N+V27/YqaqD2tHXLT1ucinYra/l0IcoIECr75p1SpTdFSytwPc7edYUC23EGpy+LvnBttXfldN1wce6Xv7wHiG3zehs77jn61B/p1LS8r0R6OEFPpKlr9FrjKyD1XC+DXIetxPkKoTkF4VF7dWrYk93l0BbisS4z1VrQTJlPvs132AQy0NI/On9xa/g7k0NZmjt/PhYjTcoeNBmoW5XRO2Xz2UqpBr8Grcn6n2ARVQRSiYO25VvrS8ZxHrkiO0+y9QphIb+aU7xRmwrK7dJH1h3cujV2xpX2Jl3xhbL2MIZYqpfRY8vgqpuzK8sIOVBFB7v76Kr4bI3gjkr84xJmkZUzJwKPJtZUnDq2xx2Pht74itH9Gc1H9rHnGUueIcZJkRykRacqoBYmXRNIzz5dD4VJsRexcl6appMosZXZyuUQXl/64NiOifEe/HhsLr4LjpFtHi06JLRxhCUHKnHa0ul8QeP7JFkDzIvk3hBeWyc0Sf7y8OJwFdqXk0o7oXY9hIX55Js9bGVy45KVcVgF1paJnMefQmUDozxCw+sqcHoVc65I/WO34FZXgSXJqkydKIcS8/2RhbH1R2yqFoiX/ZNA3PHm1Ce0F/qmWSd3Lo9qJf3h+QLZv/HxsGKFdYfsi4BVpj2s7Kka9xXzoscxobdpFdgv8V0aWT7PtWKhvN2cZ0dI2PpOKCsDxp2VySmPOHzU2/B/zRB/40TtsaZp9HLMK2nKaWmFzizPxA499O/DR4RsO77OximaRJE99suaggjP5eBdTs9YVjuL0o7YHQOF33BMcvyl23VzbWhbPXG5aAIQePjkW7k7NVwpdRCvT1Ttl0Dlm7XasM/OAqfaMv7Akqsi7AgrJ8/7+gX8hwmA+DT1SpexZgnZX1NJXXLHlHXFv3v0LlukAjJfk8qubHXsL26Qjr6SaJImAv82Ajx/9ryGHW+5gLO3FKDwAOKfvSFMOJ4SPeviskTWOPt+vBC7cNTjmu6r9MRzKXtb+DZxb433cfghiRj5cz9U14rTRSnVWG4dPVaTo+u/2XFDOheUtGwsQG8nsU+Ug4S7756axhOdPJYKghI63ucA0UaxwwLwc8AtFh4mK9Fh+X+nY6KswEktEwP5s63YsRdHbetnEpWLhb39cNNRov/owb55DAnHtliUOL1Bv5AyydVjVrZ25eMs5cPmcSUBkyd4xA+iWjuWAb2lN48Lbcnz7AFKzgEqZ5sNlNIXVpOI5n/StYSFRTrdg6qLiD5X7PpaA79MsKo3MMJ2PZd3a9x8sCVWnonnjp+oxv5netzr99UW0swa2P51nuniThMYUz1P9mvf9WWOnR4vNbwU/jPxON/o/ebo7/tDPywXz2BKGi5wWzhatCSevpk89TqZs+n7SIxzT9PZRt72BTJxtw3bmKnsCA/wY3s1hm1v7zJ11vgTcJ+ydl6yL0d9KJCtPEzghWfvJUDXXk3RJbF2awmleBntrSJzUBGNClo5Rsm6nlCOGtXpjAIxaMkNKiz/TSAbILwntvg5GPQI7UjWCNhMOsDBXGRnGdMJWFiubw8bJ5gDYHMd4fa78JVAedceN0hnOWSnOBi1hNWFD1ZG6wTA6pXcBeht0CeatAui/92KrXR1ogwF70uN9OXFZjZR4AyqvSBqIw8pZ5dmZzqFpoe6i04xsiYRrMChBNhEXTmOouklGaPHH/bwCyQlDJv2ROZR3ooU7N2QBpiw/umNbhwrrMb8Wpl1t5hxeKRHnGDhCESB8+18n9yrnw9t/ou51hicJer+73BMAO/1Mzuyt8Pu6x7hd/SzNer1pEEqlPZw4+8US0TlRuLPZlWhxuF7ET558h3hRpFNsSOwmPXoI3iMJ1ByyfDi0HDoRGnvT0UOD0xTonwxtSiuhiXp30qtX3sM5SgUE4csIr7frLHYCCkvr9MRhD3YvM/YTX4qi4VcuvsbADCEupLCu6Wq/Zci022wxbVyi+I7iqC11hhhws3AuqbA2VnCh2SScNQrmMb3zvmZPaEEnvhI8e3H4SO/tEfbDAh6ziGNyJn/WXNh0ohpcb+4esM+EwMeq7bz12uNQAvlxvmQ9tlcHW9sb4pe2W2UHsnh1ft/FlFqvOp+LV+iinU06Lr6e82QFBsu63MYzXXo9KbkCXTwskiwti8Zy18kPE+UjmXUA6DAQeGkKyjcou0CT5+fpdPEx7YoIDKFTdYJNuhLoau+qhOoXzhPVGIjcWQe4qtK6/M3vKvCrPAtbnaCF67pxg7zfHO2UL9qJPXUT1B++4vOnVu9Gwh8WKlT7fST0q4z/HurFo06n9wvMGO01KLfy3E94FTlnCbW35Y+sPM2hJkQcYs8JE8HJkwiJw5L8SudWhHOa91ZAvKeBX9Xs6dkM4V3lXJnXw+2ZsZ2QeR6keHx6eTEn0ZM/C+ap4Lx3KRhdF4ROC3CL9HFFAEdOX5hJgy3x2rvS+ZFjwfuzC8s3cV6NK/JASBlecXRuu1Zc47+U39rp4ihCH6d9z5sHIRVyefN0Iw/OcOavNi8c/tjEZL4xp36g9hWrYfOFx9A4WBuSD5v19V1C3n9Ahgv+0icsQdNYfqOZXx/iuVJX7xn78HAP5a7vPclsdHH90a2z3cCyn2WdnO1ra3nKzW+xOOKzZXEZtEZ+HUms3prjnBlQihInIpFjSvYp1lkigvYGKb3gk5uJewuRC6Mdnpdi1mw1QAr9mhL6czHQqVe1G9phCBmJ7JumKa5duuF8Yjar99JoLP3+AXqmPwP1NibYu+CpUU63p5KZyV2zjJ837/QpW0/CtYJDKyYvjmhBzwI97DH/ZP7dGfhOQTTh+jONUSK2K+RiadKZbMgLQsQkjrfcOKsio0j2PYuikdeU2cFUyy0tnPfOdhf9slmcF1oL37DwuYvV5q/9NS1y2oCkegTgCtgudRZybJk4+u+JVgjcBfhuK8v3OLUZP8ZMa6n83lVKe/xjg5RSFvXXIe1R18Q9JU+7sd5G2mC6/20VBEgnW8nb3raSqjbKF0BCp2VFIG/quRkkPqIN4l6teyaM9o4qaOwOsKgqpevHxWqDWnejJHrA7Kdc9qpNiVBNtg53MEnhPLDvKZejBLiKW78cxsDbtOuYKD+/d2qMK6iW33P7jjx+px0zHycE1+U+qUax8nTUNm9YMZDF5L9t9rIWWZ0tF5M2Ei5Nrt/NLZeHwb4eX7iQzStw5amg9sBBmbjuSzL7fts+n70Zk2mOKe3UHCxzzU4TsJ9UZT8C0PF35u2Q731lvLv3Qsst+978NIWgf3+BgxkSqJU5MQIZLtyPFaxfDhI1Q4p73o60yYqtZSeVevnZTf5Wb7JZCEmTZaJqCHVN08xZZJEf/cKxTUyBVF6M4hc8caGolQvDEqJioei2Uy/MEWYBo1yQwTmYTBrCIFy2pACbX3M4ex8vCmrMEICtPCW86sn7Inuzfr3ca41mb9MTPm7qwiwdjEcX7Xs1IIY4vCEnigKCr/rdxsmY/W1KLRvUmp547V4IZnXwgyegMJoAPGqecTSbvs9iii3NsKoo+IHDv/IOCrgGwndKpdhjdJyNsUcta8JsD7mAGlKgxGl4nlEp37OcIIT1gCThiEli6x14Q2GJ+p+tuyzpKqFbRa0cYpkWWCg2gZAHJYRFmoEq4x8DkkcbTOA1fLKs5rkmM81tQIQgrF+64X1ZwwybebwiThYFWRx8byczLn2wQnHwOiS4XsDzRT0oP+hPfmXZc9uXSyx6KwQooqLJqIl7ll5ExGZWVhqa2DGKTRkuimcH6rZLBz0fp5SPvEoump1wMwboqxWojBCNcVmKSOzqIIyjmM1xTnGFZYwQw1szeYghUJ0vc63d74MJH8/YEMeh3idHCyTqGMFOO3p37ubDXj7s6sNi97K/3p2RQyYSe5IrRAptDM9G2zyabdjEvvVQaIBEOd/SE+WaeB5+68FZcuvKwWREImAxeq2uOI7l2WybR7cNm9jfERqNkYEk/J5Li3NN8d2Dt6uj24ddPRAt7qHlxuz9z9RK9JMrdyJQxNFOlk0avEjBYyuW1uOrY7SfChC2uHoMNNVGNk2Yx3WwzE6es2syCUo6J/jJfM0j0+ytrEWBgrnE50d5uSpalbQBCpggNTRiiyZ71NWRbMZXdxB1h6mn86rGZcGwdHEvEUNN2MVi7XTP6toXAE7D2Lj+7OliGnjOVQqHiPWJ6buQbbgAH/b3YX8fWBNPtG/HKGWZg0LQieST+zXZfrnydJnydBnzZJ6n63aDxVI1+eymolrZyqe0DhrR9BPT7b0YCT7Jvmct8aSd6zi3d4nE83Y1U7mt8umy/3kPtKX/I2qe+KFBsUdJBt9s2cy8f2oW6p33jW9yXEEhV0eVJPQIzAFxqzOsL81+vAhxtiR9uKYkALrqMWNW4Cfku+Hdn3t2w5o/vhPcVZ/w5I4oFet2qIWT7rV9T+riwzAedGCIpppUhQsG1YgokhGdbFz1YvpOlUJNXbC4XhC7Lj/X52PYmrKufeQtX9dxI/koULKQVhSkpQzAGPmJJ0xWNDMXgHIPniwxpqiUMo6d5h1yh/V/qiZlwLLbZjd4bP/5hPnLnU3jII1QWUXj8j2I7z+GHw9diXnzwWb8pdluRqKrWY/ZC1m4f/AlHsVeoLLo9rIT+QaD5zy+u4SSmEEyZkzMSqcfYIRMAhBgc0H8BWn2CQxrNJzZIoPA3ht4VC3d5zR477w/Lpbo4BVk2aLPk0/ajwRozxnj4C8k7lTosgS4J/zCgT8aPR9q5aecswCrKHnL9NwFvc/suj8V+uQpLBy4F+Zk56lS5Fo+q1pAhXBbbo7jHPF9XrvsGFaKHjsEnh+bIDj/Y/CmZpE04Kz1TUlz471CyNDvHYakza9M5Jss/av9/NSHlXAbvvX/OHV18n8rDe7rrLnYGOqkEyb4qwLWhg+FypPSCg2wnWV0JLKUG/o2buM2btkmWxnpZhQ7L7oC/r4+UoX/CSTjFnEYpU6VeJyoxOZ1/aiYG47oBUZgBOb8q2aw3CCIieKt5xdfOUP0xvmJPhNVJJs4rRijSb9l1oP5HtFvqf9LiaeEtHUKFB1W2jYIU+vsxfs+MemJAHrh1n5g2bbylmqUKStAOcIcud/HXRBVbtTxDSSw7eUUqrYVYqlPF+aflKurC3euBk7TL4PDe4IjwlJS53LFqqLUQUM+hVVuV93hOUdDaXpYWugGFZELUJRsmsWErv71DBAlu2QPCWnOZkLFO0UCWnORbjS5nhqanslxlZ36pzzBLnRCnFtUUPGGLYYblS51aS7f4VeCCUu8/uy2utsy1rIR1aNRIcxEGz3Orv/W9un6H/Lh3+rDxfnw7/Jhfx/ybNH+cgwYVK4vsOoMVKA2Sn+q0STztscXdXartSS/TuhZrv1eAo4FkPlEzZwFer/0ewFNMnf0vtGycq1FlfVFz87tH4GSMW/xazNLTGvkfqwzgClW9NZ2M4L7Hb5gUyPMyM6WvSvzfjfr2KYD0pwWPQu5LVN4G57H5NPw286g8GKrORtXPZlS3zk7SdU9Cpop69o702N29XWq9rE8HbdxC8Pit2i3r0ffw+mXJvnDsO4iUcfvCHnEjvrPvrNpbu+gTtzFtQH6Szso7z9C3KfWNLD46TJKXeOg3zOAyorF1vupQvePjcq6q/T4L2y992/3YUcf9vehXlei321zPMopof1qPQxrSdZP9foYxz+FNlHPRDAdUKZ+RSZd5jyVK570r8fZgoTAhzlI1VduwUzps1lf2aXf3cDKzcA2H5bby4ug4SMWJuk5qw3V5kK92kc8m5gHS42+vsL57+/7jKNgX5vmy7MsX53icKmK8t+YkUlelIfnVdQA9/gjJ+14hxMSZ+I25O1fqwUQMHuu4FBH/2j1qscBfcTjJKhPj2dJcoFtLQINWRHWyOn395KkTFCZ04W1fXxrsj6S1/rp99RCoXq5T+o1iTi2CjVZSfm2v0YRUSl55P6aRRQrOVBbwyifgxZMhJVHPaHXpI1KNv1/dp5fzda3roXWsNhAw1qztIjm0eC47/wlJvGZ13VWPUv7hHDK/tq41KiW042uF6bsc+LEggWOio9+bjbX6+MlMgIDiZ0/do950qev9RlztF43uMus/oaE8QINoTLqnUJmvTjHCBXmO7wRgQG4dhU37JqtVFXtx08DMNbKmg/1VqHzDfYyEBMcf7gFn2Zu6wuKcdSTiMIpSd5svY/JNHQQtJg/KN1Yr4BRk/SeCvdcNjpk8PZ1FwPaGZKRYgbDFVqpgKdocdmCYV5vH+tqrzoxDA090Rsajpzkdo+MRbzVl8oQ8hN1wIovDCfUyjkAjBjvQQ6G5TrVGHTJukxDpbODN/Zm9wBUZVfRxqcoLsrvsfFawB5j7jgHF7f7QfcerdWN+9z1vqQuBvBHopXcQLpR/uk7UxVM3H+0Ai5roMtH732VkQHrq8deDHujAyowd+s19auvhOgj74xYxb7CLdqv2rFPGkQazntB9c2x4q+D9WlREK8HnpdeyTJ3eLo0wDdyrxHQ118rzx5AGexP5WcIxwmIE8EXtOFxGilIq6Hpj8A4s8dDdZI+CO/e6mN2s3IgzOj6fg/j15IRTG14Pwk5JCO/lYGj0atwyt703yb8zCCe/pauu65N2rTp6Xy579P0d63blwh0ctCd/aZh+GoBNiDa4nJRqkEfPif46ylp2seqAadPsm5bYT012nXU4SoT0SF3aTJicva0SdetmoBZge6h0wf1omBo6+xxPkDm24T3K2f/6DYWjf02rq4xwcOE15l6gXRS5iVDU5Ho3JxEtsZ4lEUdFXUTVqHO1CzrGnPlIrc5S8k3RPyKK0xhlUNxfpXkbClooNKEHkKi0RM0D4whZBA9gjikD41QL4JXF/K8Y8gB6rITdOYSFd9dTp675rnq+fnP7hs26fmEZpkxglisrye/Wr7W9/Hp3k4TtOSgyHtAj964cstibG3RA/yFMZZ3nEw2JWZ226i6qkopJm6OhRPfcMsdoIyZ25gtbsRZs0kf4V2ASg9FhhkCzHXEUqknl9fHFFyHYfUJ4/85IP+xyECy3sT9tEvVApZAwkqXY0TAXZtC4cJytHrKSw4vA7BPaQQ2wE/0NjVWl3tZDjOi6VkLh0vZs8q9w0SxwR5exXygP2xpAd3BHBESIK6c1gby2O3XnzF8d9FkUDPdWdEKU1xMHNzj0ZA2CnlPOunz/BZydnksPDv/7zx17hk5EHuVlgD1e1bK95XUzh8I+tCqfsdJFns5C2iFE0Vy2jel5F2YN7xk0glMx1eqnWkb2QDd87zbdeVzHi5cFNEwj3ZcHr5OlHH+EcPL6FXdDmmElBC3gkKvSn5r1lzkzuU0CLWjUsc77mD6+6+UZPdNhmW4GlNYngwhxcG8cAWu7gfl7HXyx8h0TidUGVonQ4XxxPSshMeIYRkt9nI/991qe7UAn6G1RdhJTKqjchD2jKN+lMMOiOA9YZnlGgjgRRvJwpGCXeTgB4a57qIyAT3jtb44KvAuWj5BU+EUedMrbC8od2+EW/NCubl6J8lZNXL6M7bR2Mvjdcxe9GSlbgJgGVPqNulCyYC9CEQKhLZIVoZu35ZioFJ4SOcLyz+WpQ4dtJ+mk6Cx0O1qMyA4nFIN4XcGQjwwVCkBFPdvLGDBSV0LwUJyOAUEB7eQhUdT4cLXAIJJm6Mm58K7rU9oKXr6wemxKprJyEchNWOVW/oQsimfoImN7N6WAqI7Zr4bfFbberHcpwOqUGA8T6tphswkLDMjC33Sd9J51SPVsCyxq2bA6xy+tznTmTK6f7DgHUvBki/ZKOig+FHhYOlRKqcgVXZagZoqdCktZ1BpmzbIZ0HRe1hYw+9DLfVE3J2Bx+p0CCyO4Qeo/LYWy4z4JYXCdpd7SLv6uSBRrgw+DZkxNAWuJb6PQX0PipOcewWZj6CN+QX0WvWIIq8ObhtmsXKMrjUrnT2VX3eBQbutO5dJA80pwRvuuFGh34EgH9jIzSc95vL6PJy0GlSsQ8MZOwUBBlaa9PITI6o/C8Dj5ht9grX3gpRCVlneA4lYFuuL6QTxfXwrD44h8cNS+oLSutviRbx8tbzAv0Spz6lpsZMGomnMz+M1mC2BMupl0whYvZpucInKDmVyQzR6fym5qHcWKS/ogK/mzmrA9dQn7rOXrq6rbvebm3Lr5as/PW6jw0837tqZ4/bSfVXeedd/tcS7nrWH6EMDwjTq8pl65JcmATwXaWhmYh2YzHJlA7phESSKclC2RPQBZSewpXlvbjdq/L4UMSPNZp9RnXbB5ZPSNNV5Vz7MeWVeK6oM+I+ypFN+9eNkCgJ7VafuOvx7KoohEA+u61I3DUmDS9NXsbT4RGqP9q2+GnT5cRwBA6BWcGSq6ut+lMnUMRIDTNGFjMtPKIdr2QhikPwGBwzaJ7SCfSzVb1+/7Pg/GQqENmi5DAXLdRIdFUwoGi6wuKc+zvfSCL+H1R7MIU0bz6VZlrHMz0NzWfkg7P41yZflkpVgzWB4FvHbYX/aoNMekMpmBJtd/iogNN1lyQqawbXr+9e4WgmESe0KQvRjZTo62ghL8zMHkqdOe8Ar3NrwTOas/NRWnk6J6Z2cCr5oduS15qJ5BZtfPk9Z/TTsMgDq6nmQ5/MiI87zuY8km9N7dOB5TmW9+StkeReURSZd8JG53YQJuVmqZgUNB8tna4o55nr28EdoQyO1KNvdG0gLYb0378MHzIPTU5SPk3FsHrPKg/aEpVkLxrgkt93cd1oIUmg/Euhi74ca5vYKihUVOqAigMo5+P8Xvm94rrvUQPDpGnTQZmCeLgCVjtEnk6TGqCEjjVxrWqAAtTSqr/BVtJH7vtwZdK5qdZeMYi/IVcb3yLGsZqvh3lcVAeq/qdgCsh73NpuHRhlAqNXbkWIIDVBkNK2qpZFi5hNHlaDqNdSqukvrtg/M7Zl7Z+ipDut8bq1L074SFzok5UebMNW0jbmOeH2tJDYmxS3Lcr+apTLEki5C2jTFHzA9NC/hiojv8CiUMZIdpVBvme5RpCxjIMC+t4p6vRcjSs+WeiHEnQCzBBqYwvjpKQO7Hv8OoPp2KvLGNKzNJECZeuFE3UbIUe4pWthdckFhJ05+sMTkAmRdiZ5C5RfdNMpxRBET9X2yimzkZwVG442aFz37jqWktNuNXCPkYwtdW8vmWW7bGiVZtOsovK2iiiD3hXhTooGfgbERoqIxwB2PFde76oGRAkTszu7bjtIjcsURuRtWYvjRMUGcUpPlcKrAO1lgKs46XOCzvwWrdYL7pywaoC/IMx/wNoBJ/kBrJuP3aSh32g4wms+xcIDMitlYg9qYSX9biGfjQgY72NUolytapR3eEF13gcfIxreSO+3w2dQBCrLi1rwVR1gREZGhhLmEOHzkAZ+ntGfPTQvDu9C4U9LPYOCrHBEnTfDtpddT2oczelzRPFRxDn8aQcchftSUc5eZWY8MF0GWf1lYLCCghkLi7WsTEicuQkGJSAN9dKkLIViVDrYU3axU+O4jbF5xYEimkZ7ly3PXGD5O3YAjilUCK/BN+pZhPtaOaK73OgcfmKbMmoUdGuPp2E5HWyMfZsCY4ABsdejwHKl35s5dEukpTJOraXIZHwgJnc/tCI3VW+j12O9OS7jjPu7TPu/jvj3EOyP2Gfi/oDnr+wa4cwgvFlSN+eDNwTrpMiQJdhSzHG7dAbMtR9P9UtNAIi9f2ApWnHkzH7tkqXw7RIz5nX2EDqi/I6pTJxm2kd5OzrzB9+Y2xHdQVeDOVwRUqyQ5OD/EYIKH0kV/ByaC2BEVdrJ6TUeCZwir7c5LLa1IRXGzAYEkvzYIk4nnRCRx8vuILVjk/1kLLUMXsSyEHpJ9/pKzL7kBYe+rmO1MCZWiF2VNV8ilukt1k03934JWGhiPOTjZM+RPqSO6KKORoC511UGQEhecvV9JXInVJ4T8tdQ5ptaVbbTW1PGdSoakHr6+AWOxxVxr8qgqj7TEqDXH/Bk31pT6OIu/xO5bbt6mxigzoP5ETcWf6G1J9+XUxDVLY/I/eavO/xAu1aH7KO3evzrMHqptQTj4uSYvO4Qe5T/ql73hH3miHpgQd7y7S+P4/1vuS0Fv3spSSl1K1dZQbzyXvDZGFT2iIaLhrvOP1FBMyoaqMnp2eD0+2ujBY3r1vAZg8qHW0xa+iFbzI2dtHTMzRzHMWf7pHoq+13X4B24oFrKmu/jIp7fqG05naRJFO06j2SytHWj0FlV12DyU8N59RJkMO/5sjFYaO81HLaUyB4UDeTNoftFMBjLyKFM5ehWL1KHi8lXG1G6BGU4DdCnnRRJcoU3TrzsFXQJRJWdJAob0OptImOkmSV5ZrYiii/G7hap3Vfd7bD2rQLmzKBeNxdJpEyoLtaLimQZ6LgzujlKhlpoaxjWoCYg1yLz9pdqSWATu3fc0EkUjJHx7aTGexWB4whr4W6wIsvdIxZIfwN7rSEuWtHalKTP6vliVEyssSY05iCfEmcoxjZGbdcZ4N/fAmH+Bv0shU0LRvGwZz359qHcA6I2OlOkFGclRBkMgGcpQEe1O/Q8CsnhTzaopI1/KuCOtv38517jfPjP65461jod98914N+tN27DNZtM3fOPnlgObu83nXI+3jWFzbvrWtrJ5L9/AtjpoU19T1BG9WzVQ32kvy05IMg5fZ72+UUyZBO6ZDQlu/5C4sB9vKKS2KSzHiFU1W7FjAYgWprLgxPNdseOKtW7/9QR5+dnNWvuKxmwCNHu5TdK5a9fBBkPryL4MnEajMwz56MVDHV7ZI5GR7PEn5O2GVzNm2QSA3Ks/hf/0pYPxsVQNz9RThUOgWeEze1rSnV/ZJiwpHmTi4FWacdTNHuTGOaL14Qsf8xhEozmvFF9QQZKZcqCAysoHlDBpJzuTdnRSylSF7VXCPRzmULdRG+Bk/tB25Cq2QOP2YnHcXDYTQNes5nDwXcz/tzSlfFF0Dd6Sz9A5b8cIKQ+Qo+PaFMSDMONzT4u9h8XrQSxsc4s6iD5z0QuB9sj1Bb2ztWG2qXZ6yvMkqBrEhRFy+uM4vOKwAhNISsV8DDuuID07emYv0ejVOMatKCpJKSMlsG1WSyKJv/y5H7HOAM0W7ZuorVqY7+3KkuOU16UrFfHjWrU4KqnWZ3UaS3Ze88votdfz6tSJTLE0NQWi6RbGDydEgq4QFaxihJzQKO/OOtAqMFfZeoFAo8oOp8yqeVIHMEOzx+MlAgdphyOCyL64wJXs//0EK9j7iOAKkXGM1fIaOnB2DwDP0EdOYvypUcKWLN0a0y5MqTS1fIq59RUj8pq91jknPPh0+BkATfe8edUgk3OyNgFYuvUF+62sr3Ix3RcanwhJ56UH3x2GMl5rhMmYzfDJxf4R7kpcBJ34y1u8Hbj5EIJHXWskG5E5T6nlyFL4IQUw13WCam92AO0LlrhyoO/+elF76sTIc9XCNaMgHhXesgv1dlw752672+Ya27OuvYERrhiVZKOmqO1F9/pY87eYOcfEA1g63De+KYDUpN2E83JFyr048CdC8de1jGksvtpLgPz1agNsmFeZSZkb83FyzZL0uY4ohwBSNWKTgiVUahmZj57z/H98Gac3Ksyyq1fObBhtg4n1TGmxuG653IbS7/OXv1Mj/ILDXSD4Ly7JCAr6F18YuXrnCDmszXsvonxW+UKlpiExmi6Aeul0ZeL6Wfeee5fnNGYNbynuLRgYXeRUfmzCtXJtHsM3XpcEvxiblaPDWP53SRs7wwCNuJOHwy75NUwSMvtVZ+xuIdfY/lT4A1R0NPwKO9L5TvVMrK5ewdTUzB60+qjMoLkPa/3omMUXTYpTBaazw4lya1tnb4vFQ26KZunrwQS97lHQ4RCsyDu7mN0cDbWFTOCjbKu60rGSwXc1BDRvsEqiPi4djmIJfi28mlVbQWq4Pi/1Gy8s2Bpx0lyPsRO+nFTbd1o1WP4i8fPqqtuezYAl3yhZyr4lPwRjyfZS9eCrL3GyELJce5WYuklNzvSlc4Uz+ET15cjs30ZeYSts2Fg2AUbOB03qRmBwURC+TgohS+fR0yNe9GPlDASwytZkPq5V8ctaQIlam+m3F7ERMppPExGCbAObXkwQIufG4V9MGvhwEQmpsgyWhRYpdUKubSIZvabpyD8en8SFo+eqhERlW+QvSpTz191QQKIxVmnOMBGTJRZ9IJ/0Xz52XJwA2pwCLS64yZeaeTGZP/KFSz9L+9J9z97w39xygPkmMxrwZuq7Za+2xayR+2prV9Q/bFqarqsjXYcfI07Q8598creGKSvld8F543K0fTDP5Sh//pY07WMa1gkq560cVKWTt7zj8Arg68cATecz4ZDilms0YQq9NE1kEl26Xdio8m/5/n8xAcshSiiHyMBZb+ixGViVx/0XORbIhZ00TTJvbT7HMKpW1qqlbIWwoZNwtk0YjXDUFIXUQrsdHiI5b2mZPEIHCn7E2g7AwaU4op+Qo85/JgzZL/X+2fBwuXhpIQjI7Xz+Q9J2mVuzHFlN2LLvHcLvxASlVXUENX6olXCtHMY0sE6YMfcvj1i0JGMjbwAGX1Pr9F26deOHb4iDccGuQrqbHCY4wAXsPasdro31mBckofqpiNyjHwQ575W5fWeA/3N2s3q4XBEWDBfbkm0+pKHwqH9jWtJbbWafblIQkI2r2qYIOe34L+HSMl/IYk1DIu9ap7r75pqmJSwSrZQUa4BnEV8cEblxbXQ7ss/CnaBQo6fo0B0sKTvfXzokkxzAc1Z4HEJlyipsOiAlbGe9K5MJwDttbgNMnvLcj1BOswiuicGjGTfatiFM1iOsMjlkVXFapkAJgmP8WSCHuz2cgQ/0BXcqCIVt2uOXB/YAdlWbt7gFL+hw2MALcgNSh8NZs1oHribt2pP38UM4ntYHjm0/aQD4YtWB1kZnJUtYdHfcf0w/kRn9Rq3RcifEcPakxhd+jXuaUuKbQ3mm6J1plrrQt0dZjdJJWR8Ss5Un4beldo5r5TXgN92aRchN1bJb9Fh3koRcza3Vp3DQkMQjHWE/a/LKQGSCEkotS/UXUIcSNpvuJ3TcPMPP+ISAABdX6YilfC0dj1W7tivrhai4Hxnnq3L3Qqi1PA0VT9ia1if0Vw7Dyw0gyopVnbOjvZGL/uhjxiIYj2ymOV9iEzD0dm7KHgpRcIRrp0l2FI/WaTWdyFEOgEc9h2hZ+4ii10JUK8fH48vQNs+jdl3l9Jvjx/MdtqmtCc5krpHMi53o3wuPbwBcsoUpT9kDSHcUJfx0Giw69Um9D4Tv4bVTyJzm1R7guCok31LGIkAKbX3iIExOINWY/kFJAGZdwi7bB6/Jeygo5y/DILKa+fgn22jK32bcMC1cjQFJ9tt3NW3QF34RX/VpJZPrA47OXl5wd3YO8Fe18QdxP/5ctxeIDc71wHNMZXkb/VkZ+h4tz2eY/aXszJCywTRxua/I1gCp2xqgcghNRvhWNoyb8n4Gd6cZkeQZ", "base64")).toString();
  return hook;
};

exports.LinkType = LinkType;
exports.generateInlinedScript = generateInlinedScript;
exports.generateLoader = generateLoader;
exports.generatePrettyJson = generatePrettyJson;
exports.generateSplitScript = generateSplitScript;
exports.getESMLoaderTemplate = builtLoader;
exports.hydratePnpFile = hydratePnpFile;
exports.hydratePnpSource = hydratePnpSource;
exports.makeRuntimeApi = makeRuntimeApi;
